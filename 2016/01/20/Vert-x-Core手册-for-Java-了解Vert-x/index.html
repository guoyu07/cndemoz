<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[Vert.x Core手册 for Java]-了解Vert.x | 全科-不安分的码农</title>
  <meta name="author" content="全科">
  
  <meta name="description" content="欢迎关注http://quanke.name/
交流群：231419585
转载请注明出处，谢谢

源码在github上
Vert.x Core提供的功能：

编写TCP客户端和服务器
编写 HTTP 客户端和服务器包括 Websocket 支持
事件总线(Event bus)
共享的数据-本地的m">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="[Vert.x Core手册 for Java]-了解Vert.x"/>
  <meta property="og:site_name" content="全科-不安分的码农"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="true" title="全科-不安分的码农" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

  
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?853906ed403c461b2dbf1df696bdf998";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">全科-不安分的码农</a></h1>
  <h2><a href="/">android，ios，html5，微服务架构，XP，scrum，项目管理（PMP）</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/app">Opus</a></li>
    
      <li><a href="/open-source">Open Source</a></li>
    
      <li><a href="/todo">TODO</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-01-20T12:39:49.000Z"><a href="/2016/01/20/Vert-x-Core手册-for-Java-了解Vert-x/">2016-01-20</a></time>
      
      
  
    <h1 class="title">[Vert.x Core手册 for Java]-了解Vert.x</h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>交流群：<code>231419585</code></li>
<li>转载请注明出处，谢谢</li>
</ul>
<p>源码在<a href="https://github.com/eclipse/vert.x" target="_blank" rel="external">github</a>上</p>
<p>Vert.x Core提供的功能：</p>
<ul>
<li>编写TCP客户端和服务器</li>
<li>编写 HTTP 客户端和服务器包括 Websocket 支持</li>
<li>事件总线(Event bus)</li>
<li>共享的数据-本地的map和分布式的map</li>
<li>定时和延时运行</li>
<li>部署和非部署 Verticles</li>
<li>Sockets</li>
<li>DNS 客户端</li>
<li>文件系统</li>
<li>高可用性</li>
<li>集群</li>
</ul>
<p>Vert.x核心功能是相当简单的 — — 你不会找到数据库访问、 授权或高级别 web 功能等，这些东西你可以在哪里找到？在这里-，<strong>Vert.x ext</strong>(扩展)。</p>
<p>Vert.x core 非常小，非常轻量级。只是使用你想要的部分。也是完全可嵌入在您现有的应用程序 — — 不强迫你使用特殊方式架构您的应用程序，这样你可以方向使用 Vert.x。</p>
<p>您可以使用任何 Vert.x 支持的其他语言的核心。这有点小酷-我们不强迫你使用 Java API ，JavaScript 或者 Ruby等都没问题 — — 毕竟，不同的语言有不同的习惯和语法，迫使Ruby 开发人员使用 Java 的语法，这会很奇怪 (举个例子)。相反，我们自动生成以 Java Api 为核心，等效、地道的每种语言。</p>
<p>从现在起我们会使用 core 指 Vert.x core。</p>
<p>如果你使用 Maven 或 Gradle，需要增加以下依赖才能使用Vert.x Core API:</p>
<ul>
<li>Maven (在你的pom.xml中):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;dependency&#62;&#10;  &#60;groupId&#62;io.vertx&#60;/groupId&#62;&#10;  &#60;artifactId&#62;vertx-core&#60;/artifactId&#62;&#10;  &#60;version&#62;3.2.0&#60;/version&#62;&#10;&#60;/dependency&#62;</span><br></pre></td></tr></table></figure>
<ul>
<li>Gradle (在您的build.gradle文件):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile io.vertx:vertx-core:3.2.0</span><br></pre></td></tr></table></figure>
<p>下面让我们来讨论 <code>core</code> 的不同概念和功能。</p>
<h3 id="从Vert-x开始">从Vert.x开始</h3><p><em>注意：这大部分是Java特有的-需要语言特有的调用方法</em></p>
<p>如果没有获得<a href="http://vertx.io/docs/apidocs/io/vertx/core/Vertx.html" target="_blank" rel="external">Vertx</a>对象，Vert.x做不了什么。</p>
<p>Vertx对象是 Vert.x 的控制中心，几乎可以做所有事，包括创建客户端和服务器，获取引用到事件总线（event bus）、 设置计时器等。</p>
<p>所以怎么获得Vertx实例?</p>
<p>如果已经嵌入了 Vert.x，然后只需创建一个实例，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vertx vertx = Vertx.vertx();</span><br></pre></td></tr></table></figure>
<p>如果使用 Verticles</p>
<p><em>注意:大多数应用程序只需要一个单一的 Vert.x 实例，但如果你需要，可以创建多个 Vert.x 实例，例如，事件总线或不同的服务器和客户端之间的隔离。</em></p>
<h4 id="创建一个指定选项的Vertx_对象">创建一个指定选项的Vertx 对象</h4><p>创建一个 Vertx 对象时，如果默认值不是正确的选择，你还可以指定选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vertx vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(40));</span><br></pre></td></tr></table></figure>
<p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html" target="_blank" rel="external">VertxOptions</a>对象有许多设置，可以配置集群、 高可用性、 池的大小等。所有设置细节在Javadoc 中有描述。</p>
<h4 id="创建群集_Vert-x_对象">创建群集 Vert.x 对象</h4><p>如果您正在创建clustered（群集） Vert.x (更多集群相关的请参阅事件总线（ event bus）)，然后通常会使用异步方式创建 Vertx 对象。</p>
<p>这是因为不同的 Vert.x 实例在群集中组合在一起，通常需要一些时间 (也许几秒钟) 的。在这段时间，我们不想阻止调用线程，所以我们把结果以异步方式给你。</p>
<h3 id="你是傻瓜吗?">你是傻瓜吗?</h3><p>你可能注意到，在前面使用fluent API（fluent API：流API，更易使用的API，也称傻瓜式API）的例子。</p>
<p>fluent API 是支持链式调用的。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.response().putHeader(&#34;Content-Type&#34;, &#34;text/plain&#34;).write(&#34;some text&#34;).end();</span><br></pre></td></tr></table></figure>
<p>整个 Vert.x Api都是这种模式，，所以要去适应它。</p>
<p>可以链式编写代码，当然你也可以按自己的喜欢，写上这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpServerResponse response = request.response();&#10;response.putHeader(&#34;Content-Type&#34;, &#34;text/plain&#34;);&#10;response.write(&#34;some text&#34;);&#10;response.end();</span><br></pre></td></tr></table></figure>
<h3 id="不要call（调用、打电话）我们，我们会call给你。">不要call（调用、打电话）我们，我们会call给你。</h3><p>Vert.x Api 是很大程度上由事件驱动的。这意味着，当事情发生在你感兴趣的Vert.x，Vert.x 会通过回调方式向您发送events。</p>
<p>一些示例events:</p>
<ul>
<li>计时器激活</li>
<li>socket收到数据</li>
<li>从磁盘读取数据</li>
<li>发生了异常</li>
<li>HTTP 服务器收到请求</li>
</ul>
<p>通过向 Vert.x Api 提供处理程序来处理事件。例如要接收一个计时器事件每一秒你会做:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertx.setPeriodic(1000, id -&#62; &#123;&#10;  // This handler will get called every second&#10;  System.out.println(&#34;timer fired!&#34;);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>或接收到 HTTP 请求:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.requestHandler(request -&#62; &#123;&#10;  // This handler will be called every time an HTTP request is received at the server&#10;  request.response().end(&#34;hello world!&#34;);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>一段时间后当 Vert.x 有一个事件，它将传递到您的处理程序 Vert.x 将它异步调用.</p>
<p>这将引导我们进入Vert.x 中的一些重要概念:</p>
<h3 id="不要阻塞我!">不要阻塞我!</h3><p>除了极少数例外 (一些文件系统操作的“同步”结束)，没有一个 Vert.x Api 阻塞调用线程。</p>
<p>如果可以立即提供的结果，它将立即返回，你通常会提供一个handle来接收过一段时间的事件。</p>
<p>由于Vert.x API没有任何阻塞的线程，这意味着你可以使用Vert.x来处理只是使用小数目线程的大量并发。</p>
<p>常规阻塞API使用线程可能会阻塞：</p>
<ul>
<li>从socket读取数据</li>
<li>向磁盘写入数据</li>
<li>向收件人发送一条消息，等待答复。</li>
<li>…</li>
</ul>
<p>在所有上述情况下，当您的线程正在等待结果时它不能做别的-这是实际上是浪费。</p>
<p>这意味着，如果你需要大量的并发使用阻塞 APIs，然后你需要大量的线程，以防止您的应用程序停止工作。</p>
<p>线程在他们所需要的内存（例如栈）和上下文切换方面有开销。</p>
<p>对于许多现代应用程序所需要的并发水平，阻塞的方法不能按比例缩放。</p>
<h3 id="Reactor和多Reactor">Reactor和多Reactor</h3><p>之前提到Vert.x API是事件驱动 - 当他们都可用时，Vert.x传递事件给处理程序。</p>
<p>在大多数情况下Vertx要求使用一种称为event loop线程的处理程序。</p>
<p>如无有 Vert.x 或您的应用程序块中，event loop可以欢快地运行将事件传递给不同的处理程序提供事件陆续到达。</p>
<p>因为没有阻塞，event loop可以在短时间内提供大量的事件。例如一个单一的event loop可以非常迅速地处理成千上万的 HTTP 请求。</p>
<p>我们把这个叫做反应器模式（<a href="http://en.wikipedia.org/wiki/Reactor_pattern" target="_blank" rel="external">Reactor Pattern</a>）.</p>
<p>你可能会有之前听说过-例如 Node.js 实现此模式。</p>
<p>标准的Reactor所有事件都运行在单一事件循环线程。</p>
<p>单个线程的麻烦是在任何一个时间它只能运行在单一的核心上(例如 Node.js 应用，如果想要实现多线程你要做很多事 。</p>
<p>而Vert.x 不同。不是单事件循环，每个 Vertx 实例都维护若干个事件循环。默认情况下，我们选择数量基于在机器上可用的内核数，但可以自己设置。</p>
<p>与 Node.js 不同是Vertx进程是可配置的，与 Node.js 不同</p>
<p>我们称这种模式多反应器（Multi-Reactor）模式，以区别于单线程的反应器模式。</p>
<p><em>注意：即使 Vertx 实例维护多个事件循环，任何特定的处理程序将永远不会被同时执行，在大多数情况下 (除了 <a href="http://vertx.io/docs/vertx-core/java/#worker_verticles" target="_blank" rel="external">worker verticles</a>) 将始终使用完全相同的事件循环调用。</em></p>
<h3 id="黄金法则_—_不要阻塞事件循环">黄金法则 — 不要阻塞事件循环</h3><p>我们已经知道 Vert.x Api 是非阻塞，并且不会堵塞事件循环。<br>如果你堵塞事件循环，那事件循环将不能做别的事，因为它被阻塞了。如果所有的event loop被阻塞了，应用程序将完全停止！</p>
<p>所以不要这样做!<strong>你已经被警告</strong>。</p>
<p>阻塞的例子包括:</p>
<ul>
<li>Thread.sleep()</li>
<li>等待锁</li>
<li>等待互斥体或监视器 (例如同步段)</li>
<li>做一个长时间的数据库操作和等待返回</li>
<li>做复杂的计算，需要很长的时间。</li>
<li>死循环。</li>
</ul>
<p>如果有上述情况停止了事件循环（event loop），需要相当长的时间，你应经立即去下一步，并等待进一步的指示。</p>
<p>这个时间具体多长？</p>
<p>具体多长时间?它取决于应用程序需要的并发量。</p>
<p>如果你有一个单一的事件循环，并且你想要处理每秒 10000 的 http 请求，然后很明显，每个请求不能超过 0.1 ms 要处理，所以你不能阻塞比这更多的时间。</p>
<p><strong>这道数学题并不是困难，作为练习留给读者。</strong></p>
<p>如果您的应用程序不响应，可能你阻塞的事件循环的地方。为了帮助您诊断此类问题，如果它检测到一段时间后事件循环还没有恢复，Vert.x会自动记录警告。如果你在日志中看到这样的警告，那么你就应该去检查应用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread vertx-eventloop-thread-3 has been blocked for 20458 ms</span><br></pre></td></tr></table></figure>
<p>Vert.x 还将提供<code>堆栈跟踪</code>来确定阻塞发生的位置。</p>
<p>如果你想关闭这些警告或更改设置，你可以在创建Vertx对象之前，使用<a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html" target="_blank" rel="external">VertxOptions</a>配置。</p>
<h3 id="运行阻塞代码">运行阻塞代码</h3><p>在完美的世界，将没有战争或饥饿，所有 Api 将使用异步写，阳光明媚，绿色的草地有跳来跳去的兔子和手牵手的小羊羔。</p>
<p><strong>但是，现实世界并不是这样。(你看过新闻最近吗?)</strong></p>
<p>事实是，大多数库，特别是在JVM的生态,Y有许多是同步API，许多的方法有可能阻塞。一个很好的例子是JDBC API - 这是本质上的同步，不管如何努力尝试，Vert.x 不能撒上魔法使之同步。</p>
<p>我们不打算在一夜之间把一切改写成异步，所以我们需要给你提供一个方法，一个Vert.x应用中安全地使用“传统”的阻塞API的方法。</p>
<p>如前所述，直接在事件循环里调用阻塞操作，会妨碍它做任何其他有用的工作。所以你怎么能这样呢?</p>
<p>它是通过调用<code>executeBlocking</code>指定要执行的阻塞的代码和在执行阻塞的代码时调用返回异步结果处理程序。</p>
<p>通过调用<code>executeblocking</code>，执行阻塞代码，当阻塞代码执行完成后通过异步回调的方式返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertx.executeBlocking(future -&#62; &#123;&#10;  // Call some blocking API that takes a significant amount of time to return&#10;  String result = someAPI.blockingMethod(&#34;hello&#34;);&#10;  future.complete(result);&#10;&#125;, res -&#62; &#123;&#10;  System.out.println(&#34;The result is: &#34; + res.result());&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>默认情况下，如果 <code>executeBlocking</code> 从相同的上下文 (例如同一垂直实例) 调用几次不同的 executeBlocking 则以串行方式执行 (即一个接一个)。</p>
<p>默认情况下，如果<code>executeBlocking</code>在同一环境（例如同一个verticle实例）多次调用，那么不同的<code>executeBlocking</code>将串行执行（即一个接一个）。</p>
<p>如果不关系执行顺序，调用<code>executeBlocking</code>时可以制定<code>ordered</code>参数为<code>false</code>。在这种情况下 <code>executeBlocking</code> 会与worker pool并行执行。</p>
<p>运行阻塞的代码替代方法是使用<a href="http://vertx.io/docs/vertx-core/java/#worker_verticles" target="_blank" rel="external">worker verticle</a></p>
<p>worker verticle始终在worker池中的线程执行。</p>
<p><a href="http://quanke.name/2016/01/20/Vert-x-Core手册-for-Java-了解Vert-x/">查看原文</a></p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/Vert-x3-系列/">Vert.x3 系列</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/Vert-x-Core手册-for-Java/">Vert.x Core手册 for Java</a>, <a href="/tags/Vert-x3/">Vert.x3</a>, <a href="/tags/Vertx/">Vertx</a>
  </div>

        
<div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_copy" data-cmd="copy" title="分享到复制网址"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="" data-title="" data-url=""></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"quanke"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->


</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:quanke.name">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Go语言/">Go语言</a><small>4</small></li>
  
    <li><a href="/categories/MBaaS-LiveOak系列/">MBaaS-LiveOak系列</a><small>4</small></li>
  
    <li><a href="/categories/Vert-x3-系列/">Vert.x3 系列</a><small>8</small></li>
  
    <li><a href="/categories/android开发/">android开发</a><small>50</small></li>
  
    <li><a href="/categories/git/">git</a><small>3</small></li>
  
    <li><a href="/categories/ios开发/">ios开发</a><small>3</small></li>
  
    <li><a href="/categories/使用/">使用</a><small>3</small></li>
  
    <li><a href="/categories/服务端开发/">服务端开发</a><small>9</small></li>
  
    <li><a href="/categories/软件工程/">软件工程</a><small>1</small></li>
  
    <li><a href="/categories/随笔/">随笔</a><small>12</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/LiveOak/">LiveOak</a><small>3</small></li>
  
    <li><a href="/tags/MBaaS/">MBaaS</a><small>4</small></li>
  
    <li><a href="/tags/Vert-x-Core手册-for-Java/">Vert.x Core手册 for Java</a><small>1</small></li>
  
    <li><a href="/tags/Vert-x3/">Vert.x3</a><small>8</small></li>
  
    <li><a href="/tags/Vertx/">Vertx</a><small>8</small></li>
  
    <li><a href="/tags/Windows10安装/">Windows10安装</a><small>1</small></li>
  
    <li><a href="/tags/android/">android</a><small>1</small></li>
  
    <li><a href="/tags/android动画/">android动画</a><small>1</small></li>
  
    <li><a href="/tags/ios/">ios</a><small>1</small></li>
  
    <li><a href="/tags/开源/">开源</a><small>1</small></li>
  
    <li><a href="/tags/总结/">总结</a><small>1</small></li>
  
    <li><a href="/tags/注意/">注意</a><small>1</small></li>
  
    <li><a href="/tags/职业规划/">职业规划</a><small>1</small></li>
  
    <li><a href="/tags/资料/">资料</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 全科
  
</div>
<div class="clearfix"></div></footer>
  <script src="//libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>