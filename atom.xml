<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>全科-不安分的码农</title>
  <subtitle>android，ios，html5，微服务架构，XP，scrum，项目管理（PMP）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://quanke.name/"/>
  <updated>2016-07-19T13:55:56.000Z</updated>
  <id>http://quanke.name/</id>
  
  <author>
    <name>全科</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>完美解决 Android 6 java.lang.AbstractMethodError</title>
    <link href="http://quanke.name/2016/07/19/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3-Android-6-java-lang-AbstractMethodError/"/>
    <id>http://quanke.name/2016/07/19/完美解决-Android-6-java-lang-AbstractMethodError/</id>
    <published>2016-07-19T13:55:13.000Z</published>
    <updated>2016-07-19T13:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>转载请注明出处，谢谢</li>
</ul>
<p>在Android Marshmallow (6.0)中有一个异常，异常信息中居然没有和APP包相关的东西，感觉这是Android SDK的一个坑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.AbstractMethodError: abstract method &#8220;int android.text.ParcelableSpan.getSpanTypeIdInternal()&#8221;</span><br></pre></td></tr></table></figure>
<p>Google一下，还真有人也遇到了同样的问题，看了半天也没有解决方案,只是解释了，为什么会有这个问题，大概就是在 Android 6.0 之后 <code>ParcelableSpan</code> 接口的 <code>getSpanTypeIdInternal</code> 和 <code>writeToParcelInternal</code> 方法是 <code>@hide</code> 标记了，多次提醒我们要看Google的文档，但是怎么解决呢？找另外的方法吧，此处不通。。。</p>
<p>既然不能实现<code>ParcelableSpan</code>接口了，那就换一种方式实现吧。</p>
<p>我换成继承<code>android.text.style.UnderlineSpan</code>类，居然可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.utan.app.utantop;&#10;&#10;import android.os.Parcel;&#10;import android.text.style.UnderlineSpan;&#10;&#10;/**&#10; * &#10; * Created by quanke.name on 2016/7/16.&#10; * App Url:utantop.com&#10; */&#10;public class UtanUnderlineSpan extends UnderlineSpan &#123;&#10;    public UtanUnderlineSpan() &#123;&#10;        super();&#10;    &#125;&#10;&#10;    public UtanUnderlineSpan(Parcel src) &#123;&#10;        super(src);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://medium.com/@numan1617/android-framework-classes-choose-wisely-2f8300f6c255#.3669g6u0m" target="_blank" rel="external">https://medium.com/@numan1617/android-framework-classes-choose-wisely-2f8300f6c255#.3669g6u0m</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Android Marshmallow (6.0)中有一个异常，异常信息中居
    
    </summary>
    
      <category term="android开发" scheme="http://quanke.name/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="android" scheme="http://quanke.name/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>完美解决 java.lang.NoClassDefFoundError  R R 巨坑</title>
    <link href="http://quanke.name/2016/07/19/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3-java-lang-NoClassDefFoundError-R-R-%E5%B7%A8%E5%9D%91/"/>
    <id>http://quanke.name/2016/07/19/完美解决-java-lang-NoClassDefFoundError-R-R-巨坑/</id>
    <published>2016-07-19T13:53:59.000Z</published>
    <updated>2016-07-19T13:54:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>转载请注明出处，谢谢</li>
</ul>
<blockquote>
<p>此坑有点大，害我同事弄了一周没有搞定</p>
</blockquote>
<p>开始的时候是报另外一个错误，也是NoClassDefFoundError异常，但这个是因为包冲突的问题,删除掉一些包就好了。但是这个问题没有这么简单。</p>
<p>首先描述一下我们的场景吧：</p>
<p>我们做了一个<code>优谈TOP</code> APP，主要的逻辑代码是在一个单独的<code>android studio module</code> 实现的，这个主要是为了可以导入到公司其他APP里面，就是把<code>优谈TOP</code>当成sdk，嵌入到公司其他APP里，我们使用<code>优谈TOP</code>单独运行的时候没有一点问题，导入到另外要一个APP的时候，问题就出现了。</p>
<p>百度，Google搜了以大堆资料，都没有解决，最后在<code>stackoverflow</code>找到了一种方案。还真可以</p>
<p><code>stackoverflow</code> 连接 <a href="http://stackoverflow.com/questions/32110859/fatal-exception-java-lang-noclassdeffounderror-android-support-v7-appcompat-r" target="_blank" rel="external">http://stackoverflow.com/questions/32110859/fatal-exception-java-lang-noclassdeffounderror-android-support-v7-appcompat-r</a></p>
<blockquote>
<p>看了这个才知道，这是Dex超出方法数的限制问题，Dex达到极限时，会创建多个Dex文件，android Lollipop 没有处理，需要在应用中处理 。</p>
</blockquote>
<h3 id="第一步：">第一步：</h3><p>在 <code>build.gradle</code> 中增加(非 <code>root</code> <code>build.gradle</code> )</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;&#10;    compile &#39;com.android.support:multidex:1.0.0&#39;&#10;&#125;&#10;defaultConfig &#123;          &#10;    multiDexEnabled true&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二步：">第二步：</h3><p>在AndroidManifest.xml增加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;application&#10;        ...&#10;        android:name=&#34;android.support.multidex.MultiDexApplication&#34;&#62;&#10;        ...&#10;&#60;/application&#62;</span><br></pre></td></tr></table></figure>
<p>如果需要自己实现 <code>Application</code>,需要重写<code>attachBaseContext</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import android.support.multidex.MultiDexApplication;&#10;import android.support.multidex.MultiDex;&#10;&#10;public class MyApplication extends MultiDexApplication &#123;&#10; // ......&#10;&#10;    @Override&#10;    protected void attachBaseContext(Context base) &#123;&#10;        super.attachBaseContext(base);&#10;        MultiDex.install(this);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import android.support.multidex.MultiDex;&#10;public class MyApplication extends Application &#123;&#10; // ......&#10;&#10;    @Override&#10;    protected void attachBaseContext(Context base) &#123;&#10;        super.attachBaseContext(base);&#10;        MultiDex.install(this);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://developer.android.com/tools/building/multidex.html#mdex-gradle" target="_blank" rel="external">https://developer.android.com/tools/building/multidex.html#mdex-gradle</a> </p>
<p>这里记录一下没有解决我的问题的方案，也许你有用：</p>
<p><a href="http://stackoverflow.com/questions/32110859/fatal-exception-java-lang-noclassdeffounderror-android-support-v7-appcompat-r?noredirect=1&amp;lq=1" target="_blank" rel="external">http://stackoverflow.com/questions/32110859/fatal-exception-java-lang-noclassdeffounderror-android-support-v7-appcompat-r?noredirect=1&amp;lq=1</a></p>
<p><a href="http://stackoverflow.com/questions/27614538/crash-java-lang-noclassdeffounderror-android-support-v7-appcompat-rlayout" target="_blank" rel="external">http://stackoverflow.com/questions/27614538/crash-java-lang-noclassdeffounderror-android-support-v7-appcompat-rlayout</a></p>
<p><a href="http://stackoverflow.com/questions/9870995/android-java-lang-noclassdeffounderror" target="_blank" rel="external">http://stackoverflow.com/questions/9870995/android-java-lang-noclassdeffounderror</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;此坑有点大，害我同事弄了一周没有搞定&lt;/p&gt;
&lt;/b
    
    </summary>
    
      <category term="android开发" scheme="http://quanke.name/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="android" scheme="http://quanke.name/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android fastjson和Realm的完美结合，有坑</title>
    <link href="http://quanke.name/2016/07/19/Android-fastjson%E5%92%8CRealm%E7%9A%84%E5%AE%8C%E7%BE%8E%E7%BB%93%E5%90%88%EF%BC%8C%E6%9C%89%E5%9D%91/"/>
    <id>http://quanke.name/2016/07/19/Android-fastjson和Realm的完美结合，有坑/</id>
    <published>2016-07-19T13:52:11.000Z</published>
    <updated>2016-07-19T13:53:34.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>转载请注明出处，谢谢</li>
</ul>
<blockquote>
<p>源码地址：<a href="https://github.com/quanke/FastjsonRealm" target="_blank" rel="external">https://github.com/quanke/FastjsonRealm</a></p>
</blockquote>
<p>Realm的安装和fastjson的安装这里就不详细说了。详细的文档在这里 <a href="https://realm.io/docs/java/" target="_blank" rel="external">https://realm.io/docs/java/</a> ，最好看英文文档，中文文档，不是最新的，而且看起来别扭。</p>
<p>现在Realm Java 的最新版本是 1.1.0，fastjson Android的版本是1.1.52</p>
<h3 id="安装Realm_Java">安装Realm Java</h3><h4 id="在项目中（最外层的build-gradle文件）build-gradle中增加">在项目中（最外层的build.gradle文件）build.gradle中增加</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript &#123;&#10;    repositories &#123;&#10;        jcenter()&#10;    &#125;&#10;    dependencies &#123;&#10;        classpath &#34;io.realm:realm-gradle-plugin:1.1.0&#34;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在应用中(一般是名为app模型)build-gradle增加">在应用中(一般是名为app模型)build.gradle增加</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &#39;realm-android&#39;</span><br></pre></td></tr></table></figure>
<h3 id="安装fastjson">安装fastjson</h3><h4 id="在应用中(一般是名为app模型)build-gradle增加-1">在应用中(一般是名为app模型)build.gradle增加</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &#39;com.alibaba:fastjson:1.1.52.android&#39;</span><br></pre></td></tr></table></figure>
<h3 id="现在我们写一个模型">现在我们写一个模型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**&#10; * &#10; * Created by quanke(http://quanke.name) on 2016/7/18.&#10; */&#10;public class User extends RealmObject implements Serializable&#123;&#10;&#10;&#10;    public User() &#123;&#10;&#10;    &#125;&#10;&#10;    private String          name;&#10;    private int             age;&#10;&#10;    @Ignore&#10;    private int             sessionId;&#10;&#10;    // Standard getters &#38; setters generated by your IDE&#8230;&#10;    public String getName() &#123; return name; &#125;&#10;    public void   setName(String name) &#123; this.name = name; &#125;&#10;    public int    getAge() &#123; return age; &#125;&#10;    public void   setAge(int age) &#123; this.age = age; &#125;&#10;    public int    getSessionId() &#123; return sessionId; &#125;&#10;    public void   setSessionId(int sessionId) &#123; this.sessionId = sessionId; &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把User对象通过fastjson转为String">把User对象通过fastjson转为String</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;/**&#10;&#10; * Created by quanke(http://quanke.name) on 2016/7/18.&#10; */&#10;public class MainActivity extends AppCompatActivity &#123;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) &#123;&#10;        super.onCreate(savedInstanceState);&#10;        setContentView(R.layout.activity_main);&#10;&#10;        User user = new User();&#10;        user.setAge(2);&#10;        user.setName(&#34;http://quanke.name&#34;);&#10;&#10;        String userStr = JSON.toJSONString(user);&#10;&#10;        Log.d(&#34;userStr:&#34;,userStr);&#10;&#10;        User userObj = JSON.parseObject(userStr,User.class);&#10;&#10;        Log.d(&#34;userObj:&#34;,userObj+&#34;&#34;);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，我以为可以完美的运行了，但是运行的时候，报异常了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.NoClassDefFoundError: rx.Observable&#10;at libcore.reflect.InternalNames.getClass(InternalNames.java:55)&#10;...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>怎么解决？这里有两种方法。。</p>
</blockquote>
<h4 id="第一种：直接使用_RxJava">第一种：直接使用 <code>RxJava</code></h4><h4 id="第二种，不想使用_RxJava，那就创建一个_Observable_空文件">第二种，不想使用 <code>RxJava</code>，那就创建一个 <code>Observable</code> 空文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package rx;&#10;&#10;public class Observable &#123;&#10;    // Dummy class required for Jackson-Databind support if&#10;    // RxJava is not a project dependency.&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>其实解决方案是官方提供的，只是里面的例子是Jackson而我用的是国产fastjson</p>
<p>Realm 的详细使用这里就不说了。。。有很多小伙伴分享了，但我还是建议看官方文档 <a href="https://realm.io/docs/java/" target="_blank" rel="external">https://realm.io/docs/java/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://gith
    
    </summary>
    
      <category term="android开发" scheme="http://quanke.name/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="android" scheme="http://quanke.name/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in Java (Java 编程思想) PDF ePub Mobi格式电子书</title>
    <link href="http://quanke.name/2016/05/08/Thinking-in-Java-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-PDF-ePub-Mobi%E6%A0%BC%E5%BC%8F%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    <id>http://quanke.name/2016/05/08/Thinking-in-Java-Java-编程思想-PDF-ePub-Mobi格式电子书/</id>
    <published>2016-05-08T08:01:19.000Z</published>
    <updated>2016-05-08T08:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>转载请注明出处，谢谢</li>
</ul>
<hr>
<p>本书来自网络，<a href="http://quanke.name">http://quanke.name</a> 整理成电子书，支持PDF,ePub,Mobi格式，方便大家下载阅读。</p>
<p>阅读地址：<a href="https://www.gitbook.com/read/book/quanke/think-in-java" target="_blank" rel="external">https://www.gitbook.com/read/book/quanke/think-in-java</a></p>
<p>下载地址：<a href="https://www.gitbook.com/book/quanke/think-in-java/" target="_blank" rel="external">https://www.gitbook.com/book/quanke/think-in-java/</a></p>
<p>github地址：<a href="https://github.com/quanke/think-in-java" target="_blank" rel="external">https://github.com/quanke/think-in-java</a></p>
<p>编辑：<a href="http://quanke.name">http://quanke.name</a></p>
<p>第13章没有编辑，觉得没有意义，Java的GUI先在应用少，有时间在编辑好。。。</p>
<p>编辑整理辛苦，还望大神们点一下star ，抚平我虚荣的心</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;本书来自网络，&lt;a href=&quot;http://quanke.name
    
    </summary>
    
      <category term="Java" scheme="http://quanke.name/categories/Java/"/>
    
    
      <category term="Java" scheme="http://quanke.name/tags/Java/"/>
    
      <category term="Java 编程思想" scheme="http://quanke.name/tags/Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>打造简单灵活的支持所有View的Android 空页面及错误页面</title>
    <link href="http://quanke.name/2016/05/06/%E6%89%93%E9%80%A0%E7%AE%80%E5%8D%95%E7%81%B5%E6%B4%BB%E7%9A%84%E6%94%AF%E6%8C%81%E6%89%80%E6%9C%89View%E7%9A%84Android-%E7%A9%BA%E9%A1%B5%E9%9D%A2%E5%8F%8A%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2/"/>
    <id>http://quanke.name/2016/05/06/打造简单灵活的支持所有View的Android-空页面及错误页面/</id>
    <published>2016-05-05T16:18:24.000Z</published>
    <updated>2016-05-07T03:33:53.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>转载请注明出处，谢谢</li>
</ul>
<hr>
<p>当页面加载数据失败，数据为空，或者数据加载中需要可以操作其他地方，我们应该怎么办？</p>
<p>体验良好的APP都会做相应的处理。</p>
<ol>
<li><p>比如网络异常，会显示一个网络异常页面，提示用户去检查网络；</p>
</li>
<li><p>数据为空时，出现一个温馨的空页面，引导用户去创建数据等；</p>
</li>
<li><p>当数据在加载中时，我想按返回按钮，想切换tab，想做更多的事情时，弹出一个loading就不是那么友好了，直接在页面的内容显示区域显示加载中，问题就解决了。</p>
</li>
</ol>
<p>这些方法各大app都在使用，但是怎么发开？每一个页面都写一个空页、面错误页面和loading页面吗？那也太恶心了吧。</p>
<p>下面我们一起打造简单灵活的支持所有View的Android 空页面及错误页面：</p>
<p>开始之前先看效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/432952-7e05ff41a62e9bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打造简单灵活的支持所有View的Android 空页面及错误页面.png"></p>
<p>继承LinearLayout</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EmptyLayout extends LinearLayout&#123;&#10;&#10;public EmptyLayout(Context context, AttributeSet attrs) &#123;&#10;        super(context, attrs);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要实现三种不同的页面，所以需要定义三种类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;/**&#10;    * The empty state&#10;    */&#10;   public final static int TYPE_EMPTY = 1;&#10;   /**&#10;    * The loading state&#10;    */&#10;   public final static int TYPE_LOADING = 2;&#10;   /**&#10;    * The error state&#10;    */&#10;   public final static int TYPE_ERROR = 3;</span><br></pre></td></tr></table></figure>
<p>定义操作方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;/**&#10;     * &#23637;&#31034;&#38169;&#35823;&#20449;&#24687;&#10;     * @param resId &#22270;&#29255;&#36164;&#28304;id&#10;     * @param text&#10;     */&#10;    public void showError(int resId,String text)&#10;&#10;/**&#10;     * &#23637;&#31034;&#31354;&#20449;&#24687;&#10;     * @param resId &#22270;&#29255;&#36164;&#28304;id&#10;     * @param text&#10;     */&#10;    public void showEmpty(int resId,String text)&#10;&#10;/**&#10;     * &#23637;&#31034;&#21152;&#36733;&#20013;&#10;     * @param resId &#22270;&#29255;&#36164;&#28304;id&#10;     * @param text&#10;     */&#10;    public void showLoading(int resId,String text)&#10;&#10;/**&#10;     *&#38544;&#34255;EmptyLayout&#10;     */&#10;    public void hide()</span><br></pre></td></tr></table></figure>
<p>获得EmptyLayout的子view，方便隐藏或者展示子view（这里的子view 一般用户展示本来的内容）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**&#10;     * &#33719;&#24471;EmptyLayout&#30340;&#23376;view&#10;     */&#10;    private void getChildViews()&#123;&#10;        int childCount = getChildCount();&#10;        Log.d(&#34;EmptyLayout&#34;,&#34;ChildCount:&#34;+childCount);&#10;        View view;&#10;        for (int i=0;i&#60;childCount;i++)&#123;&#10;            view = getChildAt(i);&#10;            if (isEmptyView(view))&#123;&#10;                continue;&#10;            &#125;&#10;            childViews.add(view);&#10;        &#125;&#10;    &#125;</span><br></pre></td></tr></table></figure>
<p>判断view 对象是否是EmptyView ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;/**&#10;     * &#21028;&#26029;view &#23545;&#35937;&#26159;&#21542;&#26159;EmptyView&#10;     * @param view&#10;     * @return&#10;     */&#10;    private boolean isEmptyView(View view)&#123;&#10;        if ((view == null||mEmptyRelativeLayout == view||view == mLoadingView||view == mEmptyView||view == mErrorView))&#123;&#10;            return true;&#10;        &#125;&#10;        return false;&#10;    &#125;</span><br></pre></td></tr></table></figure>
<p>当数据为空时调用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void showEmpty()&#123;&#10;&#10;        getChildViews(); //&#33719;&#24471;&#38500;EmptyView&#30340;&#20854;&#20182;&#23376;view&#10;        hideChildView(); //&#25226;&#23376;view&#38544;&#34255;&#20102;&#10;        this.mEmptyType = TYPE_EMPTY;&#10;        changeEmptyType();&#10;        &#10;    &#125;</span><br></pre></td></tr></table></figure>
<p>其他方法和这个类似，思路很简单，大家可以试试</p>
<p>使用很简单</p>
<p>在布局文件里增加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;name.quanke.app.libs.emptylayout.EmptyLayout&#10;        android:id=&#34;@+id/emptyLayout&#34;&#10;        android:layout_width=&#34;match_parent&#34;&#10;        android:layout_height=&#34;match_parent&#34;&#62;&#10;&#10;        &#60;TextView&#10;            android:id=&#34;@+id/textHello&#34;&#10;            android:layout_width=&#34;wrap_content&#34;&#10;            android:layout_height=&#34;wrap_content&#34;&#10;            android:text=&#34;Hello World!&#34; /&#62;&#10;&#10;&#60;/name.quanke.app.libs.emptylayout.EmptyLayout&#62;</span><br></pre></td></tr></table></figure>
<p>代码里增加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">findViewById(R.id.btnLoading).setOnClickListener(new View.OnClickListener() &#123;&#10;            @Override&#10;            public void onClick(View view) &#123;&#10;                emptyLayout.showLoading();&#10;            &#125;&#10;        &#125;);&#10;        findViewById(R.id.btnEmpty).setOnClickListener(new View.OnClickListener() &#123;&#10;            @Override&#10;            public void onClick(View view) &#123;&#10;                emptyLayout.showEmpty();&#10;            &#125;&#10;        &#125;);&#10;        findViewById(R.id.btnError).setOnClickListener(new View.OnClickListener() &#123;&#10;            @Override&#10;            public void onClick(View view) &#123;&#10;                emptyLayout.showError();&#10;            &#125;&#10;        &#125;);&#10;        findViewById(R.id.btnData).setOnClickListener(new View.OnClickListener() &#123;&#10;            @Override&#10;            public void onClick(View view) &#123;&#10;                emptyLayout.hide();&#10;            &#125;&#10;        &#125;);</span><br></pre></td></tr></table></figure>
<p>好了，使用起来就这么简单。。。支持所有的view</p>
<p>源码放在github上：<a href="https://github.com/quanke/AndroidEmptyLayout" target="_blank" rel="external">https://github.com/quanke/AndroidEmptyLayout</a></p>
<p>欢迎讨论</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;当页面加载数据失败，数据为空，或者数据加载中需要可以操作其他地方，我
    
    </summary>
    
      <category term="android开发" scheme="http://quanke.name/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="android" scheme="http://quanke.name/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Vert.x 3 Core手册 for Java 中文版</title>
    <link href="http://quanke.name/2016/05/04/Vert-x-3-Core%E6%89%8B%E5%86%8C-for-Java-%E4%B8%AD%E6%96%87%E7%89%88/"/>
    <id>http://quanke.name/2016/05/04/Vert-x-3-Core手册-for-Java-中文版/</id>
    <published>2016-05-03T23:58:21.000Z</published>
    <updated>2016-05-03T23:59:17.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>交流群：<code>231419585</code>- </li>
<li>转载请注明出处，谢谢</li>
</ul>
<ul>
<li>阅读地址：<a href="http://vertx.quanke.name/" target="_blank" rel="external">http://vertx.quanke.name/</a></li>
<li>下载地址：<a href="https://www.gitbook.com/book/quanke/vert-x-core-manual-for-java" target="_blank" rel="external">https://www.gitbook.com/book/quanke/vert-x-core-manual-for-java</a></li>
<li>本书源码地址：<a href="https://github.com/quanke/vert-x-core-manual-for-java" target="_blank" rel="external">https://github.com/quanke/vert-x-core-manual-for-java</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交流群：&lt;code&gt;231419585&lt;/code&gt;- &lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
    
    </summary>
    
      <category term="Vert.x3 系列" scheme="http://quanke.name/categories/Vert-x3-%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vert.x3" scheme="http://quanke.name/tags/Vert-x3/"/>
    
      <category term="Vertx" scheme="http://quanke.name/tags/Vertx/"/>
    
  </entry>
  
  <entry>
    <title>设计模式Java版,Gitbook开源电子书，含源码</title>
    <link href="http://quanke.name/2016/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FJava%E7%89%88-Gitbook%E5%BC%80%E6%BA%90%E7%94%B5%E5%AD%90%E4%B9%A6%EF%BC%8C%E5%90%AB%E6%BA%90%E7%A0%81/"/>
    <id>http://quanke.name/2016/05/04/设计模式Java版-Gitbook开源电子书，含源码/</id>
    <published>2016-05-03T23:56:26.000Z</published>
    <updated>2016-05-03T23:57:21.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>转载请注明出处，谢谢</li>
</ul>
<p>Sunny在CSDN技术博客中陆续发表了100多篇与设计模式学习相关的文章，涵盖了七个面向对象设计原则和24个设计模式（23个GoF设计模式 +  简单工厂模式），为了方便大家学习，<a href="http://quanke.name">http://quanke.name</a> 现将所有文章的进行了整理，方便大家下载阅读，希望能给各位带来帮助！</p>
<p>阅读地址：<a href="https://quanke.gitbooks.io/design-pattern-java/content/" target="_blank" rel="external">https://quanke.gitbooks.io/design-pattern-java/content/</a></p>
<p>下载地址：<a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="external">https://www.gitbook.com/book/quanke/design-pattern-java/</a></p>
<p>源码下载地址：<a href="http://www.chinasa.info/download/DP-Code.rar" target="_blank" rel="external">http://www.chinasa.info/download/DP-Code.rar</a></p>
<p>课件下载地址：<a href="http://www.chinasa.info/download/DP-Slides.rar" target="_blank" rel="external">http://www.chinasa.info/download/DP-Slides.rar</a></p>
<p>作者：刘伟  <a href="http://blog.csdn.net/lovelion" target="_blank" rel="external">http://blog.csdn.net/lovelion</a></p>
<p>本书编辑：<a href="http://quanke.name">http://quanke.name</a></p>
<blockquote>
<p>刘伟(Sunny)，中南大学计算机应用技术博士，国家认证系统分析师（2005年），国家认证系统架构设计师（2009年，全国第四名），高级程序员，数据库系统工程师，MCSE，MCDBA，CASI专业顾问与企业内训讲师。具有十多年软件开发、项目管理及教育培训经验，曾在NIIT（印度国家信息技术学院）担任高级讲师，主持和参与30多个软件项目的开发工作，并给国内多家公司提供软件开发、软件设计等培训服务，现主要致力于软件工程、数据挖掘等领域的教学、推广和研究工作。技术专长：软件架构、设计模式、UML、OOAD、数据挖掘等。已出版设计模式书籍四本：《设计模式》（清华大学出版社，2011年）、《设计模式实训教程》（清华大学出版社，2012年）、《设计模式的艺术——软件开发人员内功修炼之道》（清华大学出版社，2013年）、《C#设计模式》（清华大学出版社，2013年）。架构师之家www.chinasa.info站长。<br>E-mail:weiliu_china@126.com<br>微博地址：<a href="http://weibo.com/csusunny" target="_blank" rel="external">http://weibo.com/csusunny</a></p>
</blockquote>
<p>更多干货，请关注：<a href="http://quanke.name">http://quanke.name</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sunny在CSDN技术博客中陆续发表了100多篇与设计模式学习相关的文章，涵
    
    </summary>
    
      <category term="设计模式" scheme="http://quanke.name/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JAVA" scheme="http://quanke.name/tags/JAVA/"/>
    
      <category term="设计模式" scheme="http://quanke.name/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Web服务器处理HTTP压缩之gzip、deflate压缩</title>
    <link href="http://quanke.name/2016/05/01/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86HTTP%E5%8E%8B%E7%BC%A9%E4%B9%8Bgzip%E3%80%81deflate%E5%8E%8B%E7%BC%A9/"/>
    <id>http://quanke.name/2016/05/01/Web服务器处理HTTP压缩之gzip、deflate压缩/</id>
    <published>2016-05-01T07:55:53.000Z</published>
    <updated>2016-05-01T08:03:45.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>交流群：<code>231419585</code></li>
<li>转载请注明出处，谢谢</li>
</ul>
<h3 id="一、什么是gzip">一、什么是gzip</h3><p>gzip是一种数据格式，默认且目前仅使用deflate算法压缩data部分；</p>
<p>Gzip是一种流行的文件压缩算法，现在的应用十分广泛，尤其是在Linux平台。当应用Gzip压缩到一个纯文本文件时，效果是非常明显的，大约可以减少70％以上的文件大小。这取决于文件中的内容。</p>
<p>利用Apache中的Gzip模块，我们可以使用Gzip压缩算法来对Apache服务器发布的网页内容进行压缩后再传输到客户端浏览器。这样经过压缩后实际上降低了网络传输的字节数，最明显的好处就是可以加快网页加载的速度。</p>
<p>网页加载速度加快的好处不言而喻，除了节省流量，改善用户的浏览体验外，另一个潜在的好处是Gzip与搜索引擎的抓取工具有着更好的关系。例如 Google就可以通过直接读取gzip文件来比普通手工抓取更快地检索网页。在Google网站管理员工具（Google Webmaster Tools）中你可以看到，sitemap.xml.gz 是直接作为Sitemap被提交的。</p>
<p>而这些好处并不仅仅限于静态内容，PHP动态页面和其他动态生成的内容均可以通过使用Apache压缩模块压缩，加上其他的性能调整机制和相应的服务器端 缓存规则，这可以大大提高网站的性能。因此，对于部署在Linux服务器上的PHP程序，在服务器支持的情况下，我们建议你开启使用Gzip Web压缩。</p>
<p>PS：详情参考：<a href="http://baike.baidu.com/item/gzip?fr=aladdin" target="_blank" rel="external">http://baike.baidu.com/item/gzip?fr=aladdin</a></p>
<h3 id="二、什么是deflate">二、什么是deflate</h3><p>DEFLATE是同时使用了LZ77算法与哈夫曼编码（Huffman Coding）的一个无损数据压缩算法。</p>
<p>它最初是由Phil Katz为他的PKZIP归档工具第二版所定义的，后来定义在RFC 1951规范中。</p>
<p>人们普遍认为DEFLATE不受任何专利所制约，并且在LZW（GIF文件格式使用）相关的专利失效之前，这种格式除了在ZIP文件格式中得到应用之外也在gzip压缩文件以及PNG图像文件中得到了应用。</p>
<p>DEFLATE压缩与解压的源代码可以在自由、通用的压缩库zlib上找到。</p>
<p>更高压缩率的DEFLATE是7-zip所实现的。AdvanceCOMP也使用这种实现，它可以对gzip、PNG、MNG以及ZIP文件进行压缩从而得到比zlib更小的文件大小。在Ken Silverman的KZIP与PNGOUT中使用了一种更加高效同时要求更多用户输入的DEFLATE程序。</p>
<p>deflate是一种压缩算法,是huffman编码的一种加强。</p>
<p>deflate与gzip解压的代码几乎相同，可以合成一块代码。</p>
<h3 id="三、web服务器处理http压缩的过程">三、web服务器处理http压缩的过程</h3><ol>
<li>Web服务器接收到浏览器的HTTP请求后，检查浏览器是否支持HTTP压缩（Accept-Encoding 信息）；</li>
<li>如果浏览器支持HTTP压缩，Web服务器检查请求文件的后缀名；</li>
<li>如果请求文件是HTML、CSS等静态文件，Web服务器到压缩缓冲目录中检查是否已经存在请求文件的最新压缩文件；</li>
<li>如果请求文件的压缩文件不存在，Web服务器向浏览器返回未压缩的请求文件，并在压缩缓冲目录中存放请求文件的压缩文件；</li>
<li>如果请求文件的最新压缩文件已经存在，则直接返回请求文件的压缩文件；</li>
<li>如果请求文件是动态文件，Web服务器动态压缩内容并返回浏览器，压缩内容不存放到压缩缓存目录中。</li>
</ol>
<p>下面是两个演示图：<br>未使用Gzip：</p>
<p><img src="http://static.oschina.net/uploads/space/2014/1113/001348_R3PV_560358.png" alt="image"></p>
<p>开启使用Gzip后：</p>
<p><img src="http://static.oschina.net/uploads/space/2014/1113/001403_CZ4O_560358.png" alt="image"></p>
<h3 id="四、gzip与deflate区别">四、gzip与deflate区别</h3><p>deflate使用inflateInit()，而gzip使用inflateInit2()进行初始化，比 inflateInit()多一个参数: -MAX_WBITS，表示处理raw deflate数据。因为gzip数据中的zlib压缩数据块没有zlib header的两个字节。使用inflateInit2时要求zlib库忽略zlib header。在zlib手册中要求windowBits为8..15，但是实际上其它范围的数据有特殊作用，见zlib.h中的注释，如负数表示raw deflate。        </p>
<p>Apache的deflate变种可能也没有zlib header，需要添加假头后处理。即MS的错误deflate (raw deflate).zlib头第1字节一般是0x78, 第2字节与第一字节合起来的双字节应能被31整除，详见rfc1950。例如Firefox的zlib假头为0x7801，python zlib.compress()结果头部为0x789c。        </p>
<p>deflate 是最基础的算法，gzip 在 deflate 的 raw data 前增加了 10 个字节的 gzheader，尾部添加了 8 个字节的校验字节（可选 crc32 和 adler32） 和长度标识字节。</p>
<p>安装它们的Apache Web服务器版本的差异。Apache 1.x系列没有内建网页压缩技术，所以才去用额外的第三方mod_gzip 模块来执行压缩。而Apache 2.x官方在开发的时候，就把网页压缩考虑进去，内建了mod_deflate 这个模块，用以取代mod_gzip。虽然两者都是使用的Gzip压缩算法，它们的运作原理是类似的。     </p>
<p>压缩质量。mod_deflate 压缩速度略快而mod_gzip 的压缩比略高。一般默认情况下，mod_gzip 会比mod_deflate 多出4%~6％的压缩量。</p>
<p>对服务器资源的占用。 一般来说mod_gzip 对服务器CPU的占用要高一些。mod_deflate 是专门为确保服务器的性能而使用的一个压缩模块，mod_deflate 需要较少的资源来压缩文件。这意味着在高流量的服务器，使用mod_deflate 可能会比mod_gzip 加载速度更快。即在服务器性能足够的情况下，使用mod_gzip，虽然会耗费服务器性能，但是值得（压缩更快更好）；在服务器性能不足的情况下，使用mod_deflate 确保性能。</p>
<p>从Apache 2.0.45开始，mod_deflate 可使用DeflateCompressionLevel 指令来设置压缩级别。该指令的值可为1（压缩速度最快，最低的压缩质量）至9（最慢的压缩速度，压缩率最高）之间的整数，其默认值为6（压缩速度和压缩质 量较为平衡的值）。这个简单的变化更是使得mod_deflate 可以轻松媲美mod_gzip 的压缩。</p>
<h3 id="五、开启mod_gzip、mod_deflate">五、开启mod_gzip、mod_deflate</h3><p>Apache上利用Gzip压缩算法进行压缩的模块有两种：mod_gzip 和mod_deflate。 要使用Gzip Web压缩，请首先确定你的服务器开启了对这两个组件之一的支持。在Linux服务器上，现在已经有越来越多的空间商开放了对它们的支持，有的甚至是同时 支持这两个模块的。例如目前Godaddy、Bluehost及DreamHosts等空间商的服务器都已同时支持mod_gzip 和mod_deflate。        </p>
<p>通过查看HTTP头，我们可以快速判断使用的客户端浏览器是否支持接受gzip压缩。若发送的HTTP头中出现以下信息，则表明你的浏览器支持接受相应的gzip压缩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip &#25903;&#25345;mod_gzip&#10;Accept-Encoding: deflate &#25903;&#25345;mod_deflate &#10;Accept-Encoding: gzip,deflate &#21516;&#26102;&#25903;&#25345;mod_gzip &#21644;mod_deflate</span><br></pre></td></tr></table></figure>
<p>mod_deflate 是apache自带的模块,当然是在apache 2后支持的,以前1的时候是mod_gzip,启用mod_deflate可以很好的为节省网页大小,只不过是占用服务器的资源和内存.用户看到页面的速度会大大加快。在apache2.0以上（包括apache2.0）的版中gzip压缩使用的是mod_deflate模块</p>
<ol>
<li>查看apache的安装模式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apachectl -l</span><br></pre></td></tr></table></figure>
<p>发现 mod_so.c，ok可以动态加模块，不用重新编译。</p>
<ol>
<li>安装mod_deflate</li>
</ol>
<p>找到原有的apache安装包安装mod_deflate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd httpd-2.0.59/modules/filters&#10;/usr/local/apache2/bin/apxs -i -c -a mod_deflate.c</span><br></pre></td></tr></table></figure>
<p>PS：apxs命令参数说明：</p>
<p>-i  此选项表示需要执行安装操作，以安装一个或多个动态共享对象到服务器的modules目录中。</p>
<p>-a  此选项自动增加一个LoadModule行到httpd.conf文件中，以激活此模块，或者，如果此行已经存在，则启用之。</p>
<p>-A  与 -a 选项类似，但是它增加的LoadModule命令有一个井号前缀(#)，即此模块已经准备就绪但尚未启用。</p>
<p>-c  此选项表示需要执行编译操作。它首先会编译C源程序(.c)files为对应的目标代码文件(.o)，然后连接这些目标代码和files中其余的目标代码文件(.o和.a)，以生成动态共享对象dsofile 。如果没有指定 -o 选项，则此输出文件名由files中的第一个文件名推测得到，也就是默认为mod_name.so 。</p>
<p>3、修改Apache的http.conf文件，去除mod_deflate.so前面的注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule deflate_module modules/mod_deflate.so</span><br></pre></td></tr></table></figure>
<p>4、在根目录中新建.htaccess文件，定制压缩规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#GZIP&#21387;&#32553;&#27169;&#22359;&#37197;&#32622;&#60;ifmodule mod_deflate.c&#62;&#10;#&#21551;&#29992;&#23545;&#29305;&#23450;MIME&#31867;&#22411;&#20869;&#23481;&#30340;&#21387;&#32553;&#10;SetOutputFilter DEFLATESetEnvIfNoCase Request_URI .(?:gif|jpe?g|png|exe|t?gz|zip|bz2|sit|rar|pdf|mov|avi|mp3|mp4|rm)$ no-gzip dont-vary #&#35774;&#32622;&#19981;&#23545;&#21387;&#32553;&#30340;&#25991;&#20214;AddOutputFilterByType DEFLATE text/html text/css text/plain text/xml application/x-httpd-php application/x-javascript #&#35774;&#32622;&#23545;&#21387;&#32553;&#30340;&#25991;&#20214;&#60;/ifmodule&#62;</span><br></pre></td></tr></table></figure>
<p>5、对指定的文件配置缓存的生存时间，去除mod_headers.so模块前面的注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule headers_module modules/mod_headers.so</span><br></pre></td></tr></table></figure>
<p>6、在根目录中新建.htaccess文件，定制压缩规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#25991;&#20214;&#32531;&#23384;&#26102;&#38388;&#37197;&#32622;&#10;&#60;FilesMatch &#34;.(flv|gif|jpg|jpeg|png|ico|swf|js|css)$&#34;&#62;&#10;Header set Cache-Control &#34;max-age=2592000&#34;&#10;&#60;/FilesMatch&#62;</span><br></pre></td></tr></table></figure>
<p>里面的文件MIME类型可以根据自己情况添加，至于PDF 、图片、音乐文档之类的这些本身都已经高度压缩格式，重复压缩的作用不大，反而可能会因为增加CPU的处理时间及浏览器的渲染问题而降低性能。所以就没必要再通过Gzip压缩。通过以上设置后再查看返回的HTTP头，出现以下信息则表明返回的数据已经过压缩。即网站程序所配置的Gzip压缩已生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>
<p>注：不管使用mod_gzip 还是mod_deflate，此处返回的信息都一样。因为它们都是实现的gzip压缩方式。</p>
<p>遇到的问题以及解决:</p>
<p>1：</p>
<p>apach2 安装mod_deflate后restart,直接</p>
<p>load /opt/apache/modules/mod_deflate.so into server: /opt/apache/modules/mod_deflate.so: undefined symbol: deflate 异常的痛苦</p>
<p>什么ldd mod_deflate.so后再export LIB_LIBRARY_PATH呀，都试了N次，google也go了N天</p>
<p>终于在google上go出来一篇文章，终于解决，方法如下： vi /usr/local/apache2/bin/apr-config 修改LDFLAGS=” “ 为 LDFLAGS=”-lz” 然后再apxs -ica mod_deflate.c 就OK了.</p>
<p>2：<br>apach2 安装mod_deflate后restart,直接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module deflate_module is built-in and can&#39;t be loaded ...</span><br></pre></td></tr></table></figure>
<p>这说明该模块已经安装，不必再LoadModule deflate_module启用它。</p>
<p>只需做<ifmodule mod_deflate.c="">配置</ifmodule></p>
<p><a href="http://my.oschina.net/rasine/blog/343769" target="_blank" rel="external">阅读原文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交流群：&lt;code&gt;231419585&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id
    
    </summary>
    
      <category term="Vert.x3 系列" scheme="http://quanke.name/categories/Vert-x3-%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vert.x3" scheme="http://quanke.name/tags/Vert-x3/"/>
    
      <category term="Vertx" scheme="http://quanke.name/tags/Vertx/"/>
    
  </entry>
  
  <entry>
    <title>使用Gitbook写开源书籍，过一把作家瘾</title>
    <link href="http://quanke.name/2016/04/25/%E4%BD%BF%E7%94%A8Gitbook%E5%86%99%E5%BC%80%E6%BA%90%E4%B9%A6%E7%B1%8D%EF%BC%8C%E8%BF%87%E4%B8%80%E6%8A%8A%E4%BD%9C%E5%AE%B6%E7%98%BE/"/>
    <id>http://quanke.name/2016/04/25/使用Gitbook写开源书籍，过一把作家瘾/</id>
    <published>2016-04-25T01:16:28.000Z</published>
    <updated>2016-04-26T14:32:32.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>转载请注明出处，谢谢</li>
</ul>
<h3 id="初级（适合没有编程基础的童鞋看）">初级（适合没有编程基础的童鞋看）</h3><h4 id="使用GitBook_Editor_写开源书籍">使用GitBook Editor 写开源书籍</h4><p>这个是gitbook官方出的编辑器，使用简单</p>
<h5 id="首先下载GitBook_Editor">首先下载GitBook Editor</h5><p><img src="http://static.open-open.com/lib/uploadImg/20141126/20141126221113_793.png" alt="GitBook Editor"></p>
<p>下载地址：<a href="https://www.gitbook.com/editor" target="_blank" rel="external">https://www.gitbook.com/editor</a></p>
<p>支持Mac、Linux、Windows</p>
<h5 id="安装">安装</h5><h6 id="Windows">Windows</h6><ul>
<li>下载<code>gitbook-win.zip</code>；</li>
<li>解压；</li>
<li>打开<code>GitBook.exe</code>安装；</li>
</ul>
<h6 id="Mac">Mac</h6><ul>
<li>下载 <code>gitbook-mac.dmg</code>安装即可</li>
</ul>
<h6 id="Linux">Linux</h6><ul>
<li>下载 <code>gitbook-linux32.tar.gz</code></li>
<li>使用<code>tar -xvzf gitbook-linux32.tar.gz</code>解压</li>
<li>运行脚本 <code>cd GitBook &amp;&amp; ./install.sh</code>安装</li>
</ul>
<h4 id="使用">使用</h4><p>安装完成之后，如果有github账号直接，登录，但是用github登录之后也需要设置gitbook的邮箱和密码，等会儿要用到，没有账号的直接注册就好；</p>
<p>登录后，可以直接在gitbook上创建书籍，建议在<a href="https://www.gitbook.com" target="_blank" rel="external">gitbook</a>网站上创建书籍，然后通过GitBook Editor <code>clone</code> 下来；</p>
<p><code>clone</code> 下来之后 可以直接写书了，先在感觉是不是特别简单？别急，为了更爽的写作还需要继续看看下面。</p>
<p><strong>怎么和github同步？</strong></p>
<p>如果没有github账号，先注册，之后绑定<code>github</code>账号 <code>https://www.gitbook.com/@quanke/settings#social</code>（把连接中的quanke修改为自己的用户名）</p>
<p>如果绑定了了github账号，需要设置权限，<code>https://www.gitbook.com/@quanke/settings#github</code>（把连接中的quanke修改为自己的用户名）， <code>Reconnect GitHub Account</code> 选择 <code>With access to public repositories</code></p>
<p>当授权好了之后，我们来到书的设置（ <code>Settings</code> ）页面，点击设置<code>github https://www.gitbook.com/book/quanke/vert-x-core-manual-for-java/settings/github</code>（把<code>quanke</code>替换成你的用户名，把<code>vert-x-core-manual-for-java</code>替换成书名）</p>
<p>如果原来这本书是<code>github</code>里写的，直接填入<code>github</code>的地址就好，如果账号都是新建的，什么都没有，那就点击<code>Export to GitHub</code> （注意填入<code>gitbook</code>的用户名密码不是<code>github</code>的）</p>
<p>如果上面的步骤没问题，点击 <code>Add webhook</code> 就OK了，给<code>github</code>增加了一个钩子，也就是说当你的github更新的时候，会告诉gitbook</p>
<blockquote>
<p>还有一步很关键,在你的<code>GitBook Editor</code>中，打开我们刚才<code>clone</code>下来的书，点击菜单里的 <code>Book -&gt;
Repository Settings</code> ，把这个设置成为刚才导到<code>github</code>的地址，之后就可以在<code>GitBook Editor</code>写作了。。有什么不懂的，直接可以留言问我</p>
</blockquote>
<h3 id="进阶（适合有编程基础的童鞋看）">进阶（适合有编程基础的童鞋看）</h3><h4 id="gitbook_安装">gitbook 安装</h4><ol>
<li>安装npm<br>从网站 <a href="https://nodejs.org/#download" target="_blank" rel="external">https://nodejs.org/#download</a> 下载node.js源代码（点击绿色的INSTALL），<br>解压</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure&#10;make&#10;make install</span><br></pre></td></tr></table></figure>
<p>成功执行后，npm就被安装好了。</p>
<ol>
<li>gitbook 安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g gitbook-cli</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitbook -V</span><br></pre></td></tr></table></figure>
<p>查看gitbook是否安装成功。</p>
<h4 id="gitbook_使用">gitbook 使用</h4><ol>
<li>根据目录生成图书结构 </li>
</ol>
<pre><code>1<span class="class">.1</span> <span class="tag">README</span><span class="class">.md</span> 与 <span class="tag">SUMMARY</span>编写
</code></pre><p>README.md</p>
<p>这个文件相当于一本Gitbook的简介。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir test_gitbook&#10;$ touch README.md</span><br></pre></td></tr></table></figure>
<p>SUMMARY.md</p>
<p>这个文件是一本书的目录结构，使用Markdown语法，<br>如我们这本书的SUMMARY.md：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch SUMMARY.md&#10;$ vim SUMMARY.md</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* [&#31616;&#20171;](README.md)&#10;* [&#31532;&#19968;&#31456;](chapter1/README.md)&#10; - [&#31532;&#19968;&#33410;](chapter1/section1.md)&#10; - [&#31532;&#20108;&#33410;](chapter1/section2.md)&#10;* [&#31532;&#20108;&#31456;](chapter2/README.md)&#10; - [&#31532;&#19968;&#33410;](chapter2/section1.md)&#10; - [&#31532;&#20108;&#33410;](chapter2/section2.md)&#10;* [&#32467;&#26463;](end/README.md)</span><br></pre></td></tr></table></figure>
<p>1.2 生成图书结构</p>
<p>当这个目录文件创建好之后，我们可以使用Gitbook<br>的命令行工具将这个目录结构生成相应的目录及文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gitbook init&#10;$ tree . #&#26597;&#30475;&#24314;&#31435;&#30340;&#30446;&#24405;&#21644;&#25991;&#20214;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#10;&#9500;&#9472;&#9472; chapter1&#10;&#9474;   &#9500;&#9472;&#9472; README.md&#10;&#9474;   &#9500;&#9472;&#9472; section1.md&#10;&#9474;   &#9492;&#9472;&#9472; section2.md&#10;&#9500;&#9472;&#9472; chapter2&#10;&#9474;   &#9500;&#9472;&#9472; README.md&#10;&#9474;   &#9500;&#9472;&#9472; section1.md&#10;&#9474;   &#9492;&#9472;&#9472; section2.md&#10;&#9500;&#9472;&#9472; end&#10;&#9474;   &#9492;&#9472;&#9472; README.md&#10;&#9500;&#9472;&#9472; README.md&#10;&#9492;&#9472;&#9472; SUMMARY.md</span><br></pre></td></tr></table></figure>
<p>我们可以看到，gitbook给我们生成了与SUMMARY.md所<br>对应的目录及文件。</p>
<p>每个目录中，都有一个README.md文件，相当于一章的说明。</p>
<ol>
<li>生成图书</li>
</ol>
<p>2.1 输出为静态网站</p>
<p>你有两种方式输出一个静态网站：</p>
<p>2.1.1 本地预览时自动生成</p>
<p>当你在自己的电脑上编辑好图书之后，你可以使用Gitbook<br>的命令行进行本地预览：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gitbook serve .</span><br></pre></td></tr></table></figure>
<p>然后浏览器中输入 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 就可以预览生<br>成的以网页形式组织的书籍。</p>
<p>这里你会发现，你在你的图书项目的目录中多了一个名为<br>_book的文件目录，而这个目录中的文件，即是生成的静态<br>网站内容。</p>
<p>使用build参数生成到指定目录<br>与直接预览生成的静态网站文件不一样的是，使用这个命令，<br>你可以将内容输入到你所想要的目录中去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir /tmp/gitbook&#10;$ gitbook build --output=/tmp/gitbook</span><br></pre></td></tr></table></figure>
<p>2.2 输出PDF</p>
<p>输入为PDF文件，需要先使用NPM安装上gitbook pdf：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo npm install gitbook-pdf -g</span><br></pre></td></tr></table></figure></p>
<p>我在执行上面这条命令的时候出现了下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***************************************************&#10;Downloading http://cdn.bitbucket.org/ariya/phantomjs/downloads/phantomjs-1.9.7-linux-i686.tar.bz2&#10;Saving to /usr/local/lib/node_modules/gitbook-pdf/node_modules/phantomjs/phantomjs/phantomjs-1.9.7-linux-i686.tar.bz2&#10;Error: connect ETIMEDOUT&#10;    at exports._errnoException (util.js:746:11)&#10;    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1010:19)&#10;npm ERR! Linux 3.2.0-4-686-pae&#10;npm ERR! argv &#34;/usr/local/bin/node&#34; &#34;/usr/local/bin/npm&#34; &#34;install&#34; &#34;gitbook-pdf&#34; &#34;-g&#34;&#10;npm ERR! node v0.12.7&#10;npm ERR! npm  v2.11.3&#10;npm ERR! code ELIFECYCLE&#10;&#10;&#10;npm ERR! phantomjs@1.9.7-5 install: `node install.js`&#10;npm ERR! Exit status 1&#10;npm ERR! &#10;npm ERR! Failed at the phantomjs@1.9.7-5 install script &#39;node install.js&#39;.&#10;npm ERR! This is most likely a problem with the phantomjs package,&#10;npm ERR! not with npm itself.&#10;npm ERR! Tell the author that this fails on your system:&#10;npm ERR!     node install.js&#10;npm ERR! You can get their info via:&#10;npm ERR!     npm owner ls phantomjs&#10;npm ERR! There is likely additional logging output above.&#10;&#10;&#10;npm ERR! Please include the following file with any support request:&#10;npm ERR!     /home/wangxq/repository/phantomjs/npm-debug.log&#10;&#10;&#10;***************************************************</span><br></pre></td></tr></table></figure>
<p>由错误报告内容的第一行可以知道，发生错误的原因是下载<br>phantomjs发生了错误，因此我们需要手动下载和安装。</p>
<p>解决方法：[1]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git://github.com/ariya/phantomjs.git&#10;$ sudo apt-get install build-essential g++ flex bison gperf ruby perl \&#10;  libsqlite3-dev libfontconfig1-dev libicu-dev libfreetype6 libssl-dev \&#10;  libpng-dev libjpeg-dev python libx11-dev libxext-dev       #&#23433;&#35013;&#32534;&#35793;&#38656;&#35201;&#30340;&#24037;&#20855;&#21644;&#20381;&#36182;&#10;$ cd phantomjs&#10;$ git checkout 1.9.7  #&#27880;&#24847;&#65306;&#36825;&#37324;&#30340;1.9.7&#26159;phantom&#30340;&#29256;&#26412;&#21495;&#65292;&#21487;&#20197;&#30001;&#38169;&#35823;&#25253;&#21578;&#30340;&#31532;&#19968;&#34892;&#25214;&#20986; &#10;$ ./build.sh --jobs 4&#10;$ sudo cp bin/phantomjs /bin/&#10;$ sudo npm install gitbook-pdf -g  #&#37325;&#26032;&#36827;&#34892;&#23433;&#35013;</span><br></pre></td></tr></table></figure>
<p>然后，使用下面的命令，要PDF文件，首先安装依赖库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install calibre  &#10;$ gitbook -v 2.1.0 pdf .</span><br></pre></td></tr></table></figure>
<p>发生错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*****************************************************&#10;info: start conversion to pdf ....ERROR&#10;&#10;&#10;Error: Command failed: /bin/sh -c ebook-convert /tmp/tmp-29384ctltwbk/SUMMARY.html /tmp/tmp-29384ctltwbk/index.pdf --title=&#34;&#34; --comments=&#34;&#36825;&#26412;&#20070;&#26159;gitbook&#30340;&#19968;&#20010;&#20363;&#23376;&#34; --language=&#34;en&#34; --book-producer=&#34;GitBook&#34; --publisher=&#34;GitBook&#34; --chapter=&#34;descendant-or-self::*[contains(concat(&#39; &#39;, normalize-space(@class), &#39; &#39;), &#39; book-chapter &#39;)]&#34; --chapter-mark=&#34;pagebreak&#34; --page-breaks-before=&#34;/&#34; --level1-toc=&#34;descendant-or-self::*[contains(concat(&#39; &#39;, normalize-space(@class), &#39; &#39;), &#39; book-chapter-1 &#39;)]&#34; --level2-toc=&#34;descendant-or-self::*[contains(concat(&#39; &#39;, normalize-space(@class), &#39; &#39;), &#39; book-chapter-2 &#39;)]&#34; --level3-toc=&#34;descendant-or-self::*[contains(concat(&#39; &#39;, normalize-space(@class), &#39; &#39;), &#39; book-chapter-3 &#39;)]&#34; --no-chapters-in-toc --max-levels=&#34;1&#34; --breadth-first --margin-left=&#34;62&#34; --margin-right=&#34;62&#34; --margin-top=&#34;56&#34; --margin-bottom=&#34;56&#34; --pdf-default-font-size=&#34;12&#34; --pdf-mono-font-size=&#34;12&#34; --paper-size=&#34;a4&#34; --pdf-header-template=&#34;&#60;p class=&#39;header&#39;&#62;&#60;span&#62;&#60;/span&#62;&#60;/p&#62;&#34; --pdf-footer-template=&#34;&#60;p class=&#39;footer&#39;&#62;&#60;span&#62;_SECTION_&#60;/span&#62; &#60;span style=&#39;float:right;&#39;&#62;_PAGENUM_&#60;/span&#62;&#60;/p&#62;&#34;&#10;Usage: ebook-convert input_file output_file [options]&#10;&#10;&#10;Convert an ebook from one format to another.&#10;&#10;&#10;input_file is the input and output_file is the output. Both must be specified as the first two arguments to the command.&#10;&#10;&#10;The output ebook format is guessed from the file extension of output_file. output_file can also be of the special format .EXT where EXT is the output file extension. In this case, the name of the output file is derived the name of the input file. Note that the filenames must not start with a hyphen. Finally, if output_file has no extension, then it is treated as a directory and an &#34;open ebook&#34; (OEB) consisting of HTML files is written to that directory. These files are the files that would normally have been passed to the output plugin.&#10;&#10;&#10;After specifying the input and output file you can customize the conversion by specifying various options. The available options depend on the input and output file types. To get help on them specify the input and output file and then use the -h option.&#10;&#10;&#10;For full documentation of the conversion system see&#10;http://manual.calibre-ebook.com/conversion.html&#10;&#10;&#10;Whenever you pass arguments to ebook-convert that have spaces in them, enclose the arguments in quotation marks.&#10;&#10;&#10;ebook-convert: error: no such option: --pdf-default-font-size&#10;&#10;&#10;*****************************************************</span><br></pre></td></tr></table></figure>
<p>解决方法[2]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo -v &#38;&#38; wget -nv -O- https://raw.githubusercontent.com/kovidgoyal/calibre/master/setup/linux-installer.py | sudo python -c &#34;import sys; main=lambda:sys.stderr.write(&#39;Download failed\n&#39;); exec(sys.stdin.read()); main()&#34;&#10;&#10;&#10;$ gitbook -v 2.1.0 pdf .  # &#37325;&#26032;&#25191;&#34892;&#21629;&#20196;&#29983;&#25104;pdf&#65292;&#30446;&#26631;&#25991;&#20214;&#20026;book.pdf</span><br></pre></td></tr></table></figure>
<h4 id="问题">问题</h4><p>如果输入<code>gitbook init</code>命令，出现<code>Installing version 2.1.0</code>，<br>需要耐性等待安装。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;初级（适合没有编程基础的童鞋看）&quot;&gt;初级（适合没有编程基础的童鞋看）
    
    </summary>
    
      <category term="使用" scheme="http://quanke.name/categories/%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="gitbook" scheme="http://quanke.name/tags/gitbook/"/>
    
  </entry>
  
  <entry>
    <title>Android ObjectAnimator 无限循环播放，实现上下左右浮动效果</title>
    <link href="http://quanke.name/2016/04/23/Android-ObjectAnimator-%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E6%92%AD%E6%94%BE%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3%E6%B5%AE%E5%8A%A8%E6%95%88%E6%9E%9C/"/>
    <id>http://quanke.name/2016/04/23/Android-ObjectAnimator-无限循环播放，实现上下左右浮动效果/</id>
    <published>2016-04-23T11:04:41.000Z</published>
    <updated>2016-04-23T11:06:21.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>转载请注明出处，谢谢</li>
</ul>
<p><code>Android Property Animation</code> 动画有很多大神写过，都非常好，这里只通过ObjectAnimator /ValueAnimator实现上下左右浮动效果。</p>
<p>很简单看代码就好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void floatAnim(View view,int delay)&#123;&#10;    List&#60;Animator&#62; animators = new ArrayList&#60;&#62;();&#10;    ObjectAnimator translationXAnim = ObjectAnimator.ofFloat(view, &#34;translationX&#34;, -6.0f,6.0f,-6.0f);&#10;    translationXAnim.setDuration(1500);&#10;    translationXAnim.setRepeatCount(ValueAnimator.INFINITE);//&#26080;&#38480;&#24490;&#29615;&#10;    translationXAnim.setRepeatMode(ValueAnimator.INFINITE);//&#10;    translationXAnim.start();&#10;    animators.add(translationXAnim);&#10;    ObjectAnimator translationYAnim = ObjectAnimator.ofFloat(view, &#34;translationY&#34;, -3.0f,3.0f,-3.0f);&#10;    translationYAnim.setDuration(1000);&#10;    translationYAnim.setRepeatCount(ValueAnimator.INFINITE);&#10;    translationYAnim.setRepeatMode(ValueAnimator.INFINITE);&#10;    translationYAnim.start();&#10;    animators.add(translationYAnim);&#10;&#10;    AnimatorSet btnSexAnimatorSet = new AnimatorSet();&#10;    btnSexAnimatorSet.playTogether(animators);&#10;    btnSexAnimatorSet.setStartDelay(delay);&#10;    btnSexAnimatorSet.start();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>开始设置<code>setRepeatMode(ValueAnimator.INFINITE);</code>方法没有效果，只有设置<code>setRepeatCount(ValueAnimator.INFINITE)</code>才可以。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Android Property Animation&lt;/code&gt;
    
    </summary>
    
      <category term="android开发" scheme="http://quanke.name/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="android" scheme="http://quanke.name/tags/android/"/>
    
      <category term="android动画" scheme="http://quanke.name/tags/android%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>10多年码代码经验腾讯管理谈职业规划</title>
    <link href="http://quanke.name/2016/04/23/10%E5%A4%9A%E5%B9%B4%E7%A0%81%E4%BB%A3%E7%A0%81%E7%BB%8F%E9%AA%8C%E8%85%BE%E8%AE%AF%E7%AE%A1%E7%90%86%E8%B0%88%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    <id>http://quanke.name/2016/04/23/10多年码代码经验腾讯管理谈职业规划/</id>
    <published>2016-04-23T10:56:22.000Z</published>
    <updated>2016-04-25T07:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>转载请注明出处，谢谢</li>
</ul>
<blockquote>
<p>此人是我眼中的大神，曾经任职EA高级技术，腾讯技术管理，在级别提升后因为厌恶政治斗争，毅然离开腾讯开始创业。</p>
</blockquote>
<h4 id="cto眼中的牛人是什么？">cto眼中的牛人是什么？</h4><ul>
<li>有多种解决方案；</li>
<li>有架构思维；</li>
<li>一专多通；</li>
<li>有预判能力；</li>
<li>思维不单一；</li>
<li>基础扎实；</li>
<li>有一些高阶技能；</li>
</ul>
<h4 id="技术人员分工：">技术人员分工：</h4><ul>
<li><p>前端：</p>
<p>  多看别人的效果，别人做出来的模仿做出来，学习新技术，前端技术更新快，需要超级顺速的更新自己的技术</p>
</li>
<li><p>后端 （分为逻辑和服务）</p>
<ul>
<li><p>逻辑</p>
<p>  像php,生命周期相对短，变化快，更加需要学习新技术。</p>
</li>
<li><p>服务</p>
<p>  生命周期长，复用要求更加高，多考虑架构的问题</p>
</li>
</ul>
</li>
<li><p>运维</p>
<p>  对于运营来说预判能力很重要</p>
</li>
<li><p>测试</p>
<p>  一个强势的部门，如果不能强制那就不要做测试</p>
</li>
</ul>
<h4 id="铁塔模型和故宫模型">铁塔模型和故宫模型</h4><p>对于中高级技术来说，有两条技术路可以走，第一条路是成为一个技术的专家，第二条路是成为解决方案的专家，第一条路就试我们所说的铁塔模型，技术很深，优点就是，立马能有回报，前期容易实现，最后能成为行业专家，很厉害，缺点就是容易倒，受环境影响大，需要有眼光和机缘，比如以前的塞班工程师牛逼哄哄的，但是塞班幕落的时候塞班工程师就抓狂了，第二种就是故宫模型，这种模型开始的时候看不到成效，不能立即变现，但是到后面会起来，可以在自己的故宫里建立各种东西，包括铁塔，不太受环境的影响。当然也可以组合成长，先一门技术能独当一面，其他技术也学习，这就是我们所说的一专多通，这就要看自己的选择了。</p>
<h3 id="程序员高手养成：">程序员高手养成：</h3><ul>
<li>第一：ide炉火纯青；</li>
<li>第二：优先考虑有哪些解决方案，不轻易说我不能实现。；</li>
<li>第三：熟悉新技术，比如java,可能现在用不到，但需要的时候能用好；</li>
<li>第四：一定要形成自己的技术体系，心目中熟悉各种架构，提炼出自己的架构。</li>
</ul>
<h4 id="职业阶梯">职业阶梯</h4><p>1.代表初级</p>
<p>初级表现为，能实现一些基本的功能，毕业实习期一般为初级，一般一年左右</p>
<p>2.代表中级</p>
<p>中级表现为，功能基本都能实现，有一点点的分装思维，工作效率一般。</p>
<p>3.代表高级</p>
<p>高级表现为，有分装思想，考虑复用，能写出高质量，可复用，可扩展的代码，会一些一些基本的工具提高工作效率，精通一门语言</p>
<p>4.代表大牛</p>
<p>在开始的时候就有表达</p>
<p>5.行业精英</p>
<p>推动行业进步，有一定知名度</p>
<p>对于我们来说，每个人应该都要有成为行业精英的理想，但是我们生下来都是初级的，不论我们现在处于哪一位阶梯，都没有关系，这不一定是你自己的原因，有可能是没有遇到贵人，有可能是在为上上一个阶梯做准备，但是今天我们知道了，希望我们的人不要一直停留在自己阶梯。</p>
<p>从初级开始，我们每次成长都特别有成就感，比如，写了一个“Hello word”，可以被浏览器渲染出来，再写一个表单，能提交处理信息等，都是一个很有成就感的时候，这时候我们就处于阶梯的平面上，但是我们走着走着，就发现，自己很无力，比如我想做一个类似utan.com这样的网站，就要学习更多的东西，比如数据库设计、数据库管理、后端处理，服务器部署等（当然utan应该是多人合作的产物），这时候感觉自己很难提高了，遇到各种问题，踩各种坑，加班、痛苦随之而来，其实这都是正常的，这都是爬到上一个阶梯的必经之路，当爬的次数多了，就会想用石头垫在脚下，爬到上一个阶梯，当然自身的能力也会成长，就这样上中级，高级，但是要成为 牛人（4），就没有那么简单了，因为可能会遇到各种阻力，或者太滑上不去，要通过我们的智慧上去，比如，如果太滑可以借助防滑手套等等，这个自己体会。</p>
<p>还有一个层级都是行业精英，不是每个人都能成为行业精英的，要机缘，要看以前的路是否扎实，要看以前的选择是否符合发展等一系列因素都会影响我们成为行业精英。</p>
<h4 id="反PMP">反PMP</h4><p>项目管理就是一群技术不好的人，又不想放弃技术，就选择做PM，是以前在项目过程中产出的畸形产物，真正的高手是不需要PM的，我们倡导敏捷。</p>
<h4 id="最后是提问环节。">最后是提问环节。</h4><h5 id="像Android或者iOS开发这种不确定性的技术有必要转型吗？">像Android或者iOS开发这种不确定性的技术有必要转型吗？</h5><p>不一定转型，但是绝不要只关注一个技术，比如做android只做android，做iOS的值关注ios，那就悲剧了，要去学习HTML5等，不知道未来会是怎么样？开放的心态去学习新的东西是正道。</p>
<h5 id="怎么掌握新技术？">怎么掌握新技术？</h5><p>有时候行业出现了很多优秀的技术，我们都是知道技术的成长最快的过程是在项目中成长，但是公司没有采取此技术，我们怎么办？</p>
<p>先对技术有一个基本的了解，很清楚，新技术的优缺点，小规模的尝试性的在公司项目中用，最好是内部系统。</p>
<p>来自内部培训，地铁用上手机形成此文，欢迎拍砖。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;此人是我眼中的大神，曾经任职EA高级技术，腾讯技术管
    
    </summary>
    
      <category term="随笔" scheme="http://quanke.name/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="职业规划" scheme="http://quanke.name/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Vert.x 3.x版本callback hell的解决</title>
    <link href="http://quanke.name/2016/04/09/Vert-x-3-x%E7%89%88%E6%9C%ACcallback-hell%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://quanke.name/2016/04/09/Vert-x-3-x版本callback-hell的解决/</id>
    <published>2016-04-09T11:15:01.000Z</published>
    <updated>2016-04-25T07:28:07.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>交流群：<code>231419585</code></li>
<li>转载请注明出处，谢谢</li>
</ul>
<p><code>Vert.x</code>乃神器也，管玩管住还包饭，异步处理，很多人头疼的<code>callback hell</code>（回调地狱），也就是金字塔，不知不觉就走入了金字塔的陷阱里，一般<code>callback</code>都发生在异步处理期间，而异步处理，除了少数数据量极大的<code>cpu intense</code>的代码块以外（这部分主要通过降低算法时间复杂度来优化），绝大多数都集中在<code>io</code>上，将一个<code>io</code>操作包装成一个异步程序块来执行，是比较常见的优化方式，<code>vert.x</code>的<code>io</code>集中在以下几个部分。</p>
<p>第一，<a href="http://vertx.io/docs/apidocs/io/vertx/core/eventbus/EventBus.html#send-java.lang.String-java.lang.Object-" target="_blank" rel="external">eventbus.send()</a>方法。</p>
<p>第二，<code>jdbcclient.getconnection</code>以及<code>connection.update/query</code>等方法。</p>
<p>第三，httpclient.get/post等方法，其中前两个都可以通过vert.x自带的Future来对付。</p>
<p>首先我们要实例化一个<code>future</code>对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Future&#60;MyResult&#62; future = Future.future();</span><br></pre></td></tr></table></figure>
<p>然后<code>future</code>有几个方法值得注意，其中一个是<code>setHandler</code>方法，这个方法就是设置后续处理的函数，另外一个，与之相对应的是<code>completer()</code>方法，这个方法返回的就是<code>setHandler</code>方法<code>set</code>的<code>handler</code>函数，通俗点说，就是<code>getHandler()</code>方法，在<code>callback</code>位置调用该方法，就可以在<code>callback</code>的时候执行<code>handler</code>方法/函数，比如原本是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertx.eventBus().send(CommerceVerticle.class.getName(),myAsyncResult -&#62; &#123;...&#125;);</span><br></pre></td></tr></table></figure>
<p>经过改写之后，就变成了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertx.eventBus().send(CommerceVerticle.class.getName(),future.completer());&#10;future.setHandler(myAsyncResult -&#62; &#123;...&#125;);</span><br></pre></td></tr></table></figure>
<p>这样通过拆分原来的内嵌<code>lambda</code>/匿名函数来达到扁平化的效果。<br><code>callback hell</code>一个典型特征就是金字塔，也就是经过多层回调<code>/callback</code>函数嵌套之后，程序会变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ar -&#62; &#123;&#10;    ar1 -&#62; &#123;&#10;         ar2 -&#62; &#123;&#10;             ...&#10;         &#125;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>这种方式，或者<code>fp</code>里面常见的<code>(+ 1 (+ 1 (+ 1 1)))</code>;如果强行<code>format</code>的话，就会变成一个多层多次缩进的，向右凸起的金字塔，极为丑陋，但是如果不这么做，又无法保证顺序，所以为了保证顺序的同时，我们要扁平化该金字塔，那么如何保证顺序呢？<br>用<code>compose</code>方法，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Future fut1 = Future.future();&#10;Future fut2 = Future.future();&#10;fut1.compose(asyncMyResult -&#62; &#123;&#10;    ...&#10;    fut2.complete();&#10;    ...&#10;&#125;, fut2);&#10;&#10;fut2.setHandler(asyncMyResult2 -&#62; &#123;&#10;    ...&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>那么当<code>fut1</code>被触发之后，如果成功，则执行<code>compose</code>方法里面的第一个参数，也就是那个回调函数<code>/handler</code>，如果失败，则直接传递给<code>compose</code>方法的第二个参数，也就是<code>fut2</code>，依次类推，便可以很轻松地组装出你想要的扁平化链条，使得多层缩进的噩梦不再。<br>利用这种方式，可以扁平化处理<code>vertx.eventBus()</code>，<code>jdbcClient.getConnection()</code>等包含有异步<code>callback</code>的代码块。<br>至于<code>Vert.x</code>自带的<code>httpclient</code>，这个稍微有些特殊，因为执行<code>get/post</code>等方法的时候，<code>response handler</code>并不能囊括全部情况，尤其是常见的超时/<code>timeout</code>，属于<code>exception</code>范畴，也就是说，要想囊括全部返回情况，至少需要<code>response</code>的<code>body handler</code>，同时也需要一个<code>exception handler</code>，最后还要调用end方法才能将全部常见的情况全部覆盖住，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client1.get(port, ip, url, response -&#62; &#123;&#10;    response.bodyHandler(respBody -&#62; &#123;&#10;    //&#36825;&#37324;&#22788;&#29702;&#27491;&#24120;&#36820;&#22238;&#10;    &#125;);&#10;&#125;).exceptionHandler(exception -&#62; &#123;&#10;    //&#36825;&#37324;&#22788;&#29702;&#36229;&#26102;&#10;&#125;).end();</span><br></pre></td></tr></table></figure>
<p>如果要在这里面用<code>future</code>的话，需要显式处理标识成功<code>future.complete(...)</code>或者失败<code>future.fail(...)</code><br>另外，常见的<code>httpClient.getNow()</code>;等方法相当于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client1.get(port, ip, url, response -&#62; &#123;&#10;    response.bodyHandler(respBody -&#62; &#123;&#10;    //&#36825;&#37324;&#22788;&#29702;&#27491;&#24120;&#36820;&#22238;&#10;    &#125;);&#10;&#125;).end();</span><br></pre></td></tr></table></figure>
<p>也就是没有<code>exception handler</code>的普通<code>get/post</code>等方法<code>＋end</code>方法，所以如果用<code>getNow</code>等方法发送请求，会无法捕捉处理<code>timeout</code>超时异常。</p>
<p>通过这篇文章想必对Vertx如何避免callback hell有所了解。</p>
<p><a href="http://dwz.cn/34QFDQ" target="_blank" rel="external">参考此文编辑</a> 非常感谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交流群：&lt;code&gt;231419585&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;co
    
    </summary>
    
      <category term="Vert.x3 系列" scheme="http://quanke.name/categories/Vert-x3-%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vert.x3" scheme="http://quanke.name/tags/Vert-x3/"/>
    
      <category term="Vertx" scheme="http://quanke.name/tags/Vertx/"/>
    
  </entry>
  
  <entry>
    <title>Vert-x配置项VertxOptions的使用</title>
    <link href="http://quanke.name/2016/04/04/Vert-x%E9%85%8D%E7%BD%AE%E9%A1%B9VertxOptions%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://quanke.name/2016/04/04/Vert-x配置项VertxOptions的使用/</id>
    <published>2016-04-03T22:59:52.000Z</published>
    <updated>2016-04-04T00:04:24.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>交流群：<code>231419585</code></li>
<li>转载请注明出处，谢谢</li>
</ul>
<p>今天清明节，一大早被孩子吵醒，起来撸一篇关于VertxOptions的文章，此文章诞生于洗手间，读此文章可能会闻到臭臭的味道。下面正式开始：</p>
<p>在发布Vert.x实例时，需要传入一个<a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html" target="_blank" rel="external">VertxOptions</a>来实现针对Vert.x的配置项的管理，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VertxOptions options = new VertxOptions();&#10;options.setWorkerPoolSize(40)//&#20030;&#20010;&#26647;&#23376;&#65292;&#35774;&#32622;&#25903;&#25345;&#30340;Worker&#32447;&#31243;&#30340;&#26368;&#22823;&#25968;&#37327;&#10;Vertx vertx = Vertx.vertx(options);</span><br></pre></td></tr></table></figure>
<p>配置项的API说明：</p>
<ul>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setEventLoopPoolSize-int-" target="_blank" rel="external">setEventLoopPoolSize</a></p>
<p>  设置Vert.x实例中使用的Event Loop线程的数量，默认值为：2 * Runtime.getRuntime().availableProcessors()（可用的处理器个数）；</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setWorkerPoolSize-int-" target="_blank" rel="external">setWorkerPoolSize</a></p>
<p>  设置Vert.x实例中支持的Worker线程的最大数量，默认值为20；</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setInternalBlockingPoolSize-int-" target="_blank" rel="external">setInternalBlockingPoolSize</a></p>
<p>  设置内部阻塞线程池最大线程数，这个参数主要被Vert.x的一些内部操作使用，默认值为20；</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setClustered-boolean-" target="_blank" rel="external">setClustered</a></p>
<p>  是否开启Vert.x的Cluster集群模式，默认值为false；</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setClusterHost-java.lang.String-" target="_blank" rel="external">setClusterHost</a></p>
<p>  【Cluster集群模式有效】设置集群运行的默认hostname，默认值为localhost；</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setClusterPort-int-" target="_blank" rel="external">setClusterPort</a></p>
<p>  【Cluster集群模式有效】设置集群运行的端口号，可自定义固定端口号，默认值为0（随机分配）；</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setClusterPingInterval-long-" target="_blank" rel="external">setClusterPingInterval</a></p>
<p>  【Cluster集群模式有效】使用ping命令检测Cluster的时间间隔，默认20000，单位毫秒ms，即20秒；</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setClusterPingReplyInterval-long-" target="_blank" rel="external">setClusterPingReplyInterval</a></p>
<p>  【Cluster集群模式有效】集群响应ping命令的时间间隔，默认20000，单位毫秒ms，即20秒；</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setBlockedThreadCheckInterval-long-" target="_blank" rel="external">setBlockedThreadCheckInterval</a></p>
<p>  阻塞线程检查的时间间隔，默认1000，单位ms，即1秒；</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setMaxEventLoopExecuteTime-long-" target="_blank" rel="external">setMaxEventLoopExecuteTime</a></p>
<p>  Event Loop的最大执行时间，默认2l <em> 1000 </em> 1000000，单位ns，即2秒；</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setMaxWorkerExecuteTime-long-" target="_blank" rel="external">setMaxWorkerExecuteTime</a></p>
<p>  Worker线程的最大执行时间，默认60l <em> 1000 </em> 1000000，单位ns，即60秒；</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setHAEnabled-boolean-" target="_blank" rel="external">setHAEnabled</a></p>
<p>  是否支持HA架构，默认值false；（*：如果Vert.x启用了HA模式，其中一个Vert.x实例运行出现了异常或者死掉，那么这个Vert.x实例中运行的Verticle会执行重发布Redeploy的过程将运行在该实例中的Verticle实例重新发布到其他正常运行的Vert.x实例中【Verticle Fail-Over】。）</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setHAGroup-java.lang.String-" target="_blank" rel="external">setHAGroup</a></p>
<p>  【HA模式有效】支持了HA模式过后，可根据不同的组名将Vert.x进行逻辑分组，此方法设置当前Vert.x的逻辑组名，默认<strong>DEFAULT</strong>；</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setQuorumSize-int-" target="_blank" rel="external">setQuorumSize</a></p>
<p>  【HA模式有效】支持了HA模式过后，此方法设置冲裁节点的数量，默认值1；（*：这个值一旦设置过后，如果要发布Verticle组件，则需要运行环境中的节点数量达到这个值才可执行发布，比如quorum的值设置成3，如果仅仅运行了两个Vert.x实例，那么这种情况下Verticle不会被发布，必须要运行至少三个Vert.x实例，才会执行发布Deploy流程，Undeploy流程类似）</p>
</li>
<li><p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#setWarningExceptionTime-long-" target="_blank" rel="external">setWarningExceptionTime</a></p>
<p>  如果线程阻塞时间超过了这个阀值，那么就会打印警告的堆栈信息，默认为5l <em> 1000 </em> 1000000，单位ns，即5秒；</p>
</li>
</ul>
<blockquote>
<p>之后还有大招，请关注<a href="http://quanke.name/">http://quanke.name/</a> ，马化腾群：231419585</p>
</blockquote>
<p>此文参考： <a href="http://dwz.cn/32dhMF" target="_blank" rel="external">http://dwz.cn/32dhMF</a>    感谢戒子猪</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交流群：&lt;code&gt;231419585&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天清
    
    </summary>
    
      <category term="Vert.x3 系列" scheme="http://quanke.name/categories/Vert-x3-%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vert.x3" scheme="http://quanke.name/tags/Vert-x3/"/>
    
      <category term="Vertx" scheme="http://quanke.name/tags/Vertx/"/>
    
  </entry>
  
  <entry>
    <title>[Vert.x Core手册 for Java]-了解Vert.x</title>
    <link href="http://quanke.name/2016/01/20/Vert-x-Core%E6%89%8B%E5%86%8C-for-Java-%E4%BA%86%E8%A7%A3Vert-x/"/>
    <id>http://quanke.name/2016/01/20/Vert-x-Core手册-for-Java-了解Vert-x/</id>
    <published>2016-01-20T12:39:49.000Z</published>
    <updated>2016-01-20T12:46:13.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>交流群：<code>231419585</code></li>
<li>转载请注明出处，谢谢</li>
</ul>
<p>源码在<a href="https://github.com/eclipse/vert.x" target="_blank" rel="external">github</a>上</p>
<p>Vert.x Core提供的功能：</p>
<ul>
<li>编写TCP客户端和服务器</li>
<li>编写 HTTP 客户端和服务器包括 Websocket 支持</li>
<li>事件总线(Event bus)</li>
<li>共享的数据-本地的map和分布式的map</li>
<li>定时和延时运行</li>
<li>部署和非部署 Verticles</li>
<li>Sockets</li>
<li>DNS 客户端</li>
<li>文件系统</li>
<li>高可用性</li>
<li>集群</li>
</ul>
<p>Vert.x核心功能是相当简单的 — — 你不会找到数据库访问、 授权或高级别 web 功能等，这些东西你可以在哪里找到？在这里-，<strong>Vert.x ext</strong>(扩展)。</p>
<p>Vert.x core 非常小，非常轻量级。只是使用你想要的部分。也是完全可嵌入在您现有的应用程序 — — 不强迫你使用特殊方式架构您的应用程序，这样你可以方向使用 Vert.x。</p>
<p>您可以使用任何 Vert.x 支持的其他语言的核心。这有点小酷-我们不强迫你使用 Java API ，JavaScript 或者 Ruby等都没问题 — — 毕竟，不同的语言有不同的习惯和语法，迫使Ruby 开发人员使用 Java 的语法，这会很奇怪 (举个例子)。相反，我们自动生成以 Java Api 为核心，等效、地道的每种语言。</p>
<p>从现在起我们会使用 core 指 Vert.x core。</p>
<p>如果你使用 Maven 或 Gradle，需要增加以下依赖才能使用Vert.x Core API:</p>
<ul>
<li>Maven (在你的pom.xml中):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;dependency&#62;&#10;  &#60;groupId&#62;io.vertx&#60;/groupId&#62;&#10;  &#60;artifactId&#62;vertx-core&#60;/artifactId&#62;&#10;  &#60;version&#62;3.2.0&#60;/version&#62;&#10;&#60;/dependency&#62;</span><br></pre></td></tr></table></figure>
<ul>
<li>Gradle (在您的build.gradle文件):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile io.vertx:vertx-core:3.2.0</span><br></pre></td></tr></table></figure>
<p>下面让我们来讨论 <code>core</code> 的不同概念和功能。</p>
<h3 id="从Vert-x开始">从Vert.x开始</h3><p><em>注意：这大部分是Java特有的-需要语言特有的调用方法</em></p>
<p>如果没有获得<a href="http://vertx.io/docs/apidocs/io/vertx/core/Vertx.html" target="_blank" rel="external">Vertx</a>对象，Vert.x做不了什么。</p>
<p>Vertx对象是 Vert.x 的控制中心，几乎可以做所有事，包括创建客户端和服务器，获取引用到事件总线（event bus）、 设置计时器等。</p>
<p>所以怎么获得Vertx实例?</p>
<p>如果已经嵌入了 Vert.x，然后只需创建一个实例，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vertx vertx = Vertx.vertx();</span><br></pre></td></tr></table></figure>
<p>如果使用 Verticles</p>
<p><em>注意:大多数应用程序只需要一个单一的 Vert.x 实例，但如果你需要，可以创建多个 Vert.x 实例，例如，事件总线或不同的服务器和客户端之间的隔离。</em></p>
<h4 id="创建一个指定选项的Vertx_对象">创建一个指定选项的Vertx 对象</h4><p>创建一个 Vertx 对象时，如果默认值不是正确的选择，你还可以指定选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vertx vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(40));</span><br></pre></td></tr></table></figure>
<p><a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html" target="_blank" rel="external">VertxOptions</a>对象有许多设置，可以配置集群、 高可用性、 池的大小等。所有设置细节在Javadoc 中有描述。</p>
<h4 id="创建群集_Vert-x_对象">创建群集 Vert.x 对象</h4><p>如果您正在创建clustered（群集） Vert.x (更多集群相关的请参阅事件总线（ event bus）)，然后通常会使用异步方式创建 Vertx 对象。</p>
<p>这是因为不同的 Vert.x 实例在群集中组合在一起，通常需要一些时间 (也许几秒钟) 的。在这段时间，我们不想阻止调用线程，所以我们把结果以异步方式给你。</p>
<h3 id="你是傻瓜吗?">你是傻瓜吗?</h3><p>你可能注意到，在前面使用fluent API（fluent API：流API，更易使用的API，也称傻瓜式API）的例子。</p>
<p>fluent API 是支持链式调用的。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.response().putHeader(&#34;Content-Type&#34;, &#34;text/plain&#34;).write(&#34;some text&#34;).end();</span><br></pre></td></tr></table></figure>
<p>整个 Vert.x Api都是这种模式，，所以要去适应它。</p>
<p>可以链式编写代码，当然你也可以按自己的喜欢，写上这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HttpServerResponse response = request.response();&#10;response.putHeader(&#34;Content-Type&#34;, &#34;text/plain&#34;);&#10;response.write(&#34;some text&#34;);&#10;response.end();</span><br></pre></td></tr></table></figure>
<h3 id="不要call（调用、打电话）我们，我们会call给你。">不要call（调用、打电话）我们，我们会call给你。</h3><p>Vert.x Api 是很大程度上由事件驱动的。这意味着，当事情发生在你感兴趣的Vert.x，Vert.x 会通过回调方式向您发送events。</p>
<p>一些示例events:</p>
<ul>
<li>计时器激活</li>
<li>socket收到数据</li>
<li>从磁盘读取数据</li>
<li>发生了异常</li>
<li>HTTP 服务器收到请求</li>
</ul>
<p>通过向 Vert.x Api 提供处理程序来处理事件。例如要接收一个计时器事件每一秒你会做:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertx.setPeriodic(1000, id -&#62; &#123;&#10;  // This handler will get called every second&#10;  System.out.println(&#34;timer fired!&#34;);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>或接收到 HTTP 请求:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.requestHandler(request -&#62; &#123;&#10;  // This handler will be called every time an HTTP request is received at the server&#10;  request.response().end(&#34;hello world!&#34;);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>一段时间后当 Vert.x 有一个事件，它将传递到您的处理程序 Vert.x 将它异步调用.</p>
<p>这将引导我们进入Vert.x 中的一些重要概念:</p>
<h3 id="不要阻塞我!">不要阻塞我!</h3><p>除了极少数例外 (一些文件系统操作的“同步”结束)，没有一个 Vert.x Api 阻塞调用线程。</p>
<p>如果可以立即提供的结果，它将立即返回，你通常会提供一个handle来接收过一段时间的事件。</p>
<p>由于Vert.x API没有任何阻塞的线程，这意味着你可以使用Vert.x来处理只是使用小数目线程的大量并发。</p>
<p>常规阻塞API使用线程可能会阻塞：</p>
<ul>
<li>从socket读取数据</li>
<li>向磁盘写入数据</li>
<li>向收件人发送一条消息，等待答复。</li>
<li>…</li>
</ul>
<p>在所有上述情况下，当您的线程正在等待结果时它不能做别的-这是实际上是浪费。</p>
<p>这意味着，如果你需要大量的并发使用阻塞 APIs，然后你需要大量的线程，以防止您的应用程序停止工作。</p>
<p>线程在他们所需要的内存（例如栈）和上下文切换方面有开销。</p>
<p>对于许多现代应用程序所需要的并发水平，阻塞的方法不能按比例缩放。</p>
<h3 id="Reactor和多Reactor">Reactor和多Reactor</h3><p>之前提到Vert.x API是事件驱动 - 当他们都可用时，Vert.x传递事件给处理程序。</p>
<p>在大多数情况下Vertx要求使用一种称为event loop线程的处理程序。</p>
<p>如无有 Vert.x 或您的应用程序块中，event loop可以欢快地运行将事件传递给不同的处理程序提供事件陆续到达。</p>
<p>因为没有阻塞，event loop可以在短时间内提供大量的事件。例如一个单一的event loop可以非常迅速地处理成千上万的 HTTP 请求。</p>
<p>我们把这个叫做反应器模式（<a href="http://en.wikipedia.org/wiki/Reactor_pattern" target="_blank" rel="external">Reactor Pattern</a>）.</p>
<p>你可能会有之前听说过-例如 Node.js 实现此模式。</p>
<p>标准的Reactor所有事件都运行在单一事件循环线程。</p>
<p>单个线程的麻烦是在任何一个时间它只能运行在单一的核心上(例如 Node.js 应用，如果想要实现多线程你要做很多事 。</p>
<p>而Vert.x 不同。不是单事件循环，每个 Vertx 实例都维护若干个事件循环。默认情况下，我们选择数量基于在机器上可用的内核数，但可以自己设置。</p>
<p>与 Node.js 不同是Vertx进程是可配置的，与 Node.js 不同</p>
<p>我们称这种模式多反应器（Multi-Reactor）模式，以区别于单线程的反应器模式。</p>
<p><em>注意：即使 Vertx 实例维护多个事件循环，任何特定的处理程序将永远不会被同时执行，在大多数情况下 (除了 <a href="http://vertx.io/docs/vertx-core/java/#worker_verticles" target="_blank" rel="external">worker verticles</a>) 将始终使用完全相同的事件循环调用。</em></p>
<h3 id="黄金法则_—_不要阻塞事件循环">黄金法则 — 不要阻塞事件循环</h3><p>我们已经知道 Vert.x Api 是非阻塞，并且不会堵塞事件循环。<br>如果你堵塞事件循环，那事件循环将不能做别的事，因为它被阻塞了。如果所有的event loop被阻塞了，应用程序将完全停止！</p>
<p>所以不要这样做!<strong>你已经被警告</strong>。</p>
<p>阻塞的例子包括:</p>
<ul>
<li>Thread.sleep()</li>
<li>等待锁</li>
<li>等待互斥体或监视器 (例如同步段)</li>
<li>做一个长时间的数据库操作和等待返回</li>
<li>做复杂的计算，需要很长的时间。</li>
<li>死循环。</li>
</ul>
<p>如果有上述情况停止了事件循环（event loop），需要相当长的时间，你应经立即去下一步，并等待进一步的指示。</p>
<p>这个时间具体多长？</p>
<p>具体多长时间?它取决于应用程序需要的并发量。</p>
<p>如果你有一个单一的事件循环，并且你想要处理每秒 10000 的 http 请求，然后很明显，每个请求不能超过 0.1 ms 要处理，所以你不能阻塞比这更多的时间。</p>
<p><strong>这道数学题并不是困难，作为练习留给读者。</strong></p>
<p>如果您的应用程序不响应，可能你阻塞的事件循环的地方。为了帮助您诊断此类问题，如果它检测到一段时间后事件循环还没有恢复，Vert.x会自动记录警告。如果你在日志中看到这样的警告，那么你就应该去检查应用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread vertx-eventloop-thread-3 has been blocked for 20458 ms</span><br></pre></td></tr></table></figure>
<p>Vert.x 还将提供<code>堆栈跟踪</code>来确定阻塞发生的位置。</p>
<p>如果你想关闭这些警告或更改设置，你可以在创建Vertx对象之前，使用<a href="http://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html" target="_blank" rel="external">VertxOptions</a>配置。</p>
<h3 id="运行阻塞代码">运行阻塞代码</h3><p>在完美的世界，将没有战争或饥饿，所有 Api 将使用异步写，阳光明媚，绿色的草地有跳来跳去的兔子和手牵手的小羊羔。</p>
<p><strong>但是，现实世界并不是这样。(你看过新闻最近吗?)</strong></p>
<p>事实是，大多数库，特别是在JVM的生态,Y有许多是同步API，许多的方法有可能阻塞。一个很好的例子是JDBC API - 这是本质上的同步，不管如何努力尝试，Vert.x 不能撒上魔法使之同步。</p>
<p>我们不打算在一夜之间把一切改写成异步，所以我们需要给你提供一个方法，一个Vert.x应用中安全地使用“传统”的阻塞API的方法。</p>
<p>如前所述，直接在事件循环里调用阻塞操作，会妨碍它做任何其他有用的工作。所以你怎么能这样呢?</p>
<p>它是通过调用<code>executeBlocking</code>指定要执行的阻塞的代码和在执行阻塞的代码时调用返回异步结果处理程序。</p>
<p>通过调用<code>executeblocking</code>，执行阻塞代码，当阻塞代码执行完成后通过异步回调的方式返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertx.executeBlocking(future -&#62; &#123;&#10;  // Call some blocking API that takes a significant amount of time to return&#10;  String result = someAPI.blockingMethod(&#34;hello&#34;);&#10;  future.complete(result);&#10;&#125;, res -&#62; &#123;&#10;  System.out.println(&#34;The result is: &#34; + res.result());&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>默认情况下，如果 <code>executeBlocking</code> 从相同的上下文 (例如同一垂直实例) 调用几次不同的 executeBlocking 则以串行方式执行 (即一个接一个)。</p>
<p>默认情况下，如果<code>executeBlocking</code>在同一环境（例如同一个verticle实例）多次调用，那么不同的<code>executeBlocking</code>将串行执行（即一个接一个）。</p>
<p>如果不关系执行顺序，调用<code>executeBlocking</code>时可以制定<code>ordered</code>参数为<code>false</code>。在这种情况下 <code>executeBlocking</code> 会与worker pool并行执行。</p>
<p>运行阻塞的代码替代方法是使用<a href="http://vertx.io/docs/vertx-core/java/#worker_verticles" target="_blank" rel="external">worker verticle</a></p>
<p>worker verticle始终在worker池中的线程执行。</p>
<p><a href="http://quanke.name/2016/01/20/Vert-x-Core手册-for-Java-了解Vert-x/">查看原文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交流群：&lt;code&gt;231419585&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;源码在
    
    </summary>
    
      <category term="Vert.x3 系列" scheme="http://quanke.name/categories/Vert-x3-%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vert.x Core手册 for Java" scheme="http://quanke.name/tags/Vert-x-Core%E6%89%8B%E5%86%8C-for-Java/"/>
    
      <category term="Vert.x3" scheme="http://quanke.name/tags/Vert-x3/"/>
    
      <category term="Vertx" scheme="http://quanke.name/tags/Vertx/"/>
    
  </entry>
  
  <entry>
    <title>Vert.x 通过异步的方式使用JDBC连接SQL</title>
    <link href="http://quanke.name/2016/01/16/Vert-x-%E9%80%9A%E8%BF%87%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8JDBC%E8%BF%9E%E6%8E%A5SQL/"/>
    <id>http://quanke.name/2016/01/16/Vert-x-通过异步的方式使用JDBC连接SQL/</id>
    <published>2016-01-16T09:45:54.000Z</published>
    <updated>2016-01-17T13:21:36.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>交流群：<code>231419585</code></li>
<li>转载请注明出处，谢谢</li>
</ul>
<p>在这篇文章中，我们将会看到怎样在vert.x应用中使用<a href="http://hsqldb.org/" target="_blank" rel="external">HSQL</a>，当然也可以使用任意JDBC，以及使用vertx-jdbc-client提供的异步的API，这篇文章的代码在<a href="https://github.com/quanke/vertx3_study_demo/tree/master/my-vertx-first-app-jdbc" target="_blank" rel="external">github</a>上。</p>
<h3 id="异步？">异步？</h3><p>vert.x一个很重要的特点就是它的异步性。使用异步的API，不需要等结果返回，当有结果返回时，vert.x会主动通知。为了说明这个，我们来看一个简单的例子。</p>
<p>我们假设有个<code>add</code>方法。一般来说，会像<code>int r = add(1, 1)</code>这样来使用它。这是一个同步的API，所以你必须等到返回结果。异步的API会是这样：<code>add(1, 1, r -&gt; { /*do something with the result*/})</code>。在这个版本中，你传入了一个Handler，当结果计算出来时才被调用。这个方法不返回任何东西，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void add(int a, int b, Handler&#60;Integer&#62; resultHandler) &#123;&#10;    int r = a + b;&#10;    resultHandler.handle(r);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免混淆概念，异步API并不是多线程。像我们在add例子里看到的，并没有涉及多线程。</p>
<h3 id="异步JDBC">异步JDBC</h3><p>看了一些基本的异步的API，现在了解下<code>vertx-jdbc-client</code>。这个组件能够让我们通过<code>JDBC driver</code>与数据库交互。这些交互都是异步的，以前这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String sql = &#34;SELECT * FROM Products&#34;;&#10;ResultSet rs = stmt.executeQuery(sql);</span><br></pre></td></tr></table></figure>
<p>现在要这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&#34;SELECT * FROM Products&#34;, result -&#62; &#123;&#10;        // do something with the result&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>这个模型更高效，当结果出来后vert.x通知，避免了等待结果。</p>
<h3 id="增加maven依赖">增加maven依赖</h3><p>在<code>pom.xml</code>文件中增加两个 <code>Maven dependencies</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;dependency&#62;&#10;  &#60;groupId&#62;io.vertx&#60;/groupId&#62;&#10;  &#60;artifactId&#62;vertx-jdbc-client&#60;/artifactId&#62;&#10;  &#60;version&#62;3.1.0&#60;/version&#62;&#10;&#60;/dependency&#62;&#10;&#60;dependency&#62;&#10;  &#60;groupId&#62;org.hsqldb&#60;/groupId&#62;&#10;  &#60;artifactId&#62;hsqldb&#60;/artifactId&#62;&#10;  &#60;version&#62;2.3.3&#60;/version&#62;&#10;&#60;/dependency&#62;</span><br></pre></td></tr></table></figure>
<p>第一个依赖提供了<code>vertx-jdbc-client</code>，第二个提供了<code>HSQL JDBC</code>的驱动。如果你想使用另外一个数据库，修改这个依赖，同时你还需要修改<code>JDBC url</code>和<code>JDBC driver</code>名。</p>
<h3 id="初始化JDBC_client">初始化JDBC client</h3><p>创建JDBC 客户端（client）：</p>
<p>在<code>MyFirstVerticle</code>类中，声明一个新变量<code>JDBCClient jdbc</code>，并且在<code>start</code>方法中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc = JDBCClient.createShared(vertx, config(), &#34;My-Whisky-Collection&#34;);</span><br></pre></td></tr></table></figure>
<p>创建了一个JDBC client实例，使用verticle的配置文件配置JDBC client。这个配置文件需要提供下面的配置才能让JDBC client正常工作：</p>
<ul>
<li>url－JDBC url，例如：<code>jdbc:hsqldb:mem:db?shutdown=true</code></li>
<li>_driver class－JDBC的驱动，例如：<code>org.hsqldb.jdbcDriver</code></li>
</ul>
<p>有了client，接下来需要连接数据库。连接数据库是通过使用<code>jdbc.getConnection</code>来实现的，<code>jdbc.getConnection</code>需要传入一个<code>Handler&lt;AsyncResult&lt;SQLConnection&gt;&gt;</code>参数。我们深入的了解下这个类型。首先，这是一个<code>Handler</code>，因此当结果准备好时它就会被调用。这个结果是<code>AsyncResult&lt;SQLConnection&gt;</code>的一个实例。<code>AsyncResult</code>是<code>vert.x</code>提供的一个结构，使用它能够知道连接数据库的操作是成功或失败了。如果成功了，它就会提供一个结果，这里结果是一个<code>SQLConnection</code>的实例。</p>
<p>当你接收一个<code>AsyncResult</code>的实例时，代码通常是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (ar.failed()) &#123;&#10;  System.err.println(&#34;The operation has failed...: &#34;&#10;      + ar.cause().getMessage());&#10;&#125; else &#123;&#10;  // Use the result:&#10;  result = ar.result();&#10; &#125;</span><br></pre></td></tr></table></figure>
<p>需要获取到<code>SQLConnection</code>，然后启动<code>rest</code>的应用。因为变成了异步的，这需要改变启动应用的方式。因此，如果将启动序列划分成多块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">startBackend(&#10; (connection) -&#62; createSomeData(connection,&#10;     (nothing) -&#62; startWebApp(&#10;         (http) -&#62; completeStartup(http, fut)&#10;     ), fut&#10; ), fut);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>startBackend</code>- 获取<code>SQLConnection</code>对象，然后调用下一步</li>
<li><code>createSomeData</code>- 初始化数据库并插入数据。当完成后，调用下一步</li>
<li><code>startWebApp</code>- 启动web应用</li>
<li><code>completeStartup</code>- 最后完成启动</li>
</ul>
<p><code>fut</code>由vert.x传入，通知已经启动或者启动过程中遇到的问题。</p>
<p><code>startBackend</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void startBackend(Handler&#60;AsyncResult&#60;SQLConnection&#62;&#62; next, Future&#60;Void&#62; fut) &#123;&#10;    jdbc.getConnection(ar -&#62; &#123;&#10;      if (ar.failed()) &#123;&#10;        fut.fail(ar.cause());&#10;      &#125; else &#123;&#10;        next.handle(Future.succeededFuture(ar.result()));&#10;      &#125;&#10;    &#125;);&#10;  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法获取了一个SQLConnection对象，检查操作是否完成。如果成功，会调用下一步。失败了，就会报告一个错误。其他的方法遵循同样的模式：</p>
<ul>
<li>检查上一步操作是否成功</li>
<li>处理业务逻辑</li>
<li>调用下一步</li>
</ul>
<h3 id="SQL">SQL</h3><p>客户端已经准备好了，现在写SQL。从<code>createSomeData</code>方法开始，这个方法也是启动顺序中的一部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void createSomeData(AsyncResult&#60;SQLConnection&#62; result,&#10;    Handler&#60;AsyncResult&#60;Void&#62;&#62; next, Future&#60;Void&#62; fut) &#123;&#10;    if (result.failed()) &#123;&#10;      fut.fail(result.cause());&#10;    &#125; else &#123;&#10;      SQLConnection connection = result.result();&#10;      connection.execute(&#10;          &#34;CREATE TABLE IF NOT EXISTS Whisky (id INTEGER IDENTITY, name varchar(100), &#34; +&#10;          &#34;origin varchar(100))&#34;,&#10;          ar -&#62; &#123;&#10;            if (ar.failed()) &#123;&#10;              fut.fail(ar.cause());&#10;              connection.close();&#10;              return;&#10;            &#125;&#10;            connection.query(&#34;SELECT * FROM Whisky&#34;, select -&#62; &#123;&#10;              if (select.failed()) &#123;&#10;                fut.fail(ar.cause());&#10;                connection.close();&#10;                return;&#10;              &#125;&#10;              if (select.result().getNumRows() == 0) &#123;&#10;                insert(&#10;                    new Whisky(&#34;Bowmore 15 Years Laimrig&#34;, &#34;Scotland, Islay&#34;),&#10;                    connection,&#10;                    (v) -&#62; insert(new Whisky(&#34;Talisker 57&#176; North&#34;, &#34;Scotland, Island&#34;),&#10;                        connection,&#10;                        (r) -&#62; &#123;&#10;                          next.handle(Future.&#60;Void&#62;succeededFuture());&#10;                          connection.close();&#10;                        &#125;));                                                    &#10;              &#125; else &#123;&#10;                next.handle(Future.&#60;Void&#62;succeededFuture());&#10;                connection.close();&#10;              &#125;&#10;            &#125;);&#10;          &#125;);&#10;    &#125;&#10;  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法检查<code>SQLConnection</code>是否可用，然后执行一些SQL语句。首先，如果表不存在就创建表。看看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.execute(&#10;    SQL statement,&#10;    handler called when the statement has been executed&#10;)</span><br></pre></td></tr></table></figure>
<p><code>handler</code>接收<code>AsyncResult&lt;Void&gt;</code>，例如：只有是通知而已，没有实际返回的结果。</p>
<h5 id="关闭连接">关闭连接</h5><p><em>操作完成后，别忘了关闭SQL链接。这个连接会被放入连接池并且可以被重复利用。</em></p>
<p>在这个<code>handler</code>的代码里，检查了<code>statement</code>是否正确的执行了，如果正确，我们接下来检查表是否含有数据，如果没有，将会使用<code>insert</code>方法插入数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void insert(Whisky whisky, SQLConnection connection, Handler&#60;AsyncResult&#60;Whisky&#62;&#62; next) &#123;&#10;  String sql = &#34;INSERT INTO Whisky (name, origin) VALUES ?, ?&#34;;&#10;  connection.updateWithParams(sql,&#10;      new JsonArray().add(whisky.getName()).add(whisky.getOrigin()),&#10;      (ar) -&#62; &#123;&#10;        if (ar.failed()) &#123;&#10;          next.handle(Future.failedFuture(ar.cause()));&#10;          return;&#10;        &#125;&#10;        UpdateResult result = ar.result();&#10;        // Build a new whisky instance with the generated id.&#10;        Whisky w = new Whisky(result.getKeys().getInteger(0), whisky.getName(), whisky.getOrigin());&#10;        next.handle(Future.succeededFuture(w));&#10;      &#125;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法使用带有INSERT（插入）statement（声明）的<code>upateWithParams</code>方法，且传入了值。这个方法避免了<code>SQL</code>注入。一旦statement执行了（当数据库没有此条数据就会创建），就创建一个新的<code>Whisky</code>对象，自动生成ID。</p>
<h3 id="带有数据库（SQL）的REST">带有数据库（SQL）的REST</h3><p>上面的方法都是启动顺序的一部分。但是，关于调用REST API的方法又是怎么样的呢？以<code>getAll</code>方法为例。这个方法被web应用前端调用，并检索存储的所有的产品：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void getAll(RoutingContext routingContext) &#123;&#10;    jdbc.getConnection(ar -&#62; &#123;&#10;      SQLConnection connection = ar.result();&#10;      connection.query(&#34;SELECT * FROM Whisky&#34;, result -&#62; &#123;&#10;        List&#60;Whisky&#62; whiskies = result.result().getRows().stream().map(Whisky::new).collect(Collectors.toList());&#10;        routingContext.response()&#10;            .putHeader(&#34;content-type&#34;, &#34;application/json; charset=utf-8&#34;)&#10;            .end(Json.encodePrettily(whiskies));&#10;        connection.close(); // Close the connection        &#10;      &#125;);&#10;    &#125;);&#10;  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法获得了一个<code>SQLConnection</code>对象，然后发出一个查询。一旦获取到查询结果，它会像之前的方法一样写<code>HTTP response</code>。<code>getOne</code>、<code>deleteOne</code>、<code>updateOne</code>和<code>addOne</code>方法都是一样的。注意，在response之后，需要要关闭SQL连接。</p>
<p>看下传入到query方法的handler提供的结果。获取了一个包含了查询结果的ResultSet。每一行都是一个JsonObject，因此，如果你有一个数据对象使用JsonObject作为唯一的参数，那么创建这个对象很简单。</p>
<h3 id="测试">测试</h3><p>需要小小的更新下测试程序，增加配置<code>JDBCClient</code>。在<code>MyFirstVerticleTest</code>类中，将<code>setUp</code>方法中创建的<code>DeploymentOption</code>对象修改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DeploymentOptions options = new DeploymentOptions()&#10;        .setConfig(new JsonObject()&#10;            .put(&#34;http.port&#34;, port)&#10;            .put(&#34;url&#34;, &#34;jdbc:hsqldb:mem:test?shutdown=true&#34;)&#10;            .put(&#34;driver_class&#34;, &#34;org.hsqldb.jdbcDriver&#34;)&#10;        );</span><br></pre></td></tr></table></figure>
<p>除了<code>http.port</code>，还配置了<code>JDBC url</code>和<code>JDBC</code>驱动。测试时，使用的是一个内存数据库。在<code>src/test/resources/my-it-config.json</code>文件中也要做同样的修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#10;  &#34;http.port&#34;: $&#123;http.port&#125;,&#10;  &#34;url&#34;: &#34;jdbc:hsqldb:mem:it-test?shutdown=true&#34;,&#10;  &#34;driver_class&#34;: &#34;org.hsqldb.jdbcDriver&#34;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><code>src/main/conf/my-application-conf.json</code>文件也同样需要修改，这不是为了测试，而是为了运行这个应用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#10;  &#34;http.port&#34; : 8082,&#10;  &#34;url&#34;: &#34;jdbc:hsqldb:file:db/whiskies&#34;,&#10;  &#34;driver_class&#34;: &#34;org.hsqldb.jdbcDriver&#34;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里这个<code>JDBC url</code>和上一个文件的有点不一样，因为需要将数据库存储到硬盘中。</p>
<h3 id="展示时间！">展示时间！</h3><p>开始构建程序：</p>
<p><code>mvn clean package</code></p>
<p>没有修改API（没有更改发布的java文件和REST接口），测试应该是可以顺利的运行的。</p>
<p>启动应用：</p>
<p><code>java -jar target/my-first-app-1.0-SNAPSHOT-fat.jar -conf src/main/conf/my-application-conf.json</code></p>
<p>访问<code>http://localhost:8082/assets/index.html</code>，然后，你可以看到这个应用使用的是数据库了。这一次，就算重启应用，这些数据仍然在，因为存储产品被持久化到硬盘里了。</p>
<h3 id="总结">总结</h3><p>这篇文章中，知道了怎么在<code>vert.x</code>里使用<code>JDBC</code>数据库，并没有很多复杂的东西。开始可能会被这个异步的开发模型惊讶到，但是，一旦你开始使用了，你就很难再回去了。</p>
<p>下一次，我们将看到这个应用怎么使用mongoDB来替换HSQL。</p>
<p><em>Stay tuned, and happy coding !</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交流群：&lt;code&gt;231419585&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这篇
    
    </summary>
    
      <category term="Vert.x3 系列" scheme="http://quanke.name/categories/Vert-x3-%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vert.x3" scheme="http://quanke.name/tags/Vert-x3/"/>
    
      <category term="Vertx" scheme="http://quanke.name/tags/Vertx/"/>
    
  </entry>
  
  <entry>
    <title>怎样写一个安全的Vert.x Web apps</title>
    <link href="http://quanke.name/2016/01/16/%E6%80%8E%E6%A0%B7%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84Vert-x-Web-apps/"/>
    <id>http://quanke.name/2016/01/16/怎样写一个安全的Vert-x-Web-apps/</id>
    <published>2016-01-16T08:36:32.000Z</published>
    <updated>2016-07-22T14:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>交流群：<code>231419585</code></li>
<li>转载请注明出处，谢谢</li>
</ul>
<p>此文只是对vert.x Web应用程序的入门指导（大神请绕道）。 这绝不是对Web应用程序安全性的全面指导，如<a href="https://www.owasp.org" target="_blank" rel="external">OWASP</a>。 标准规则和惯例适用于vert.x应用程序。</p>
<h3 id="不要用root身份运行">不要用root身份运行</h3><p>DEVOPS团队成员会经常说，只给必要的运行权限，不要多给。有些新手试图以root用户在80或443端口下运行，虽然这样简单，但也为坏蛋打开一扇门。 让我们看看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;public class App extends AbstractVerticle &#123;&#10;  @Override&#10;  public void start() &#123;&#10;&#10;    Router router = Router.router(vertx);&#10;&#10;    router.route().handler(StaticHandler.create(&#34;&#34;));&#10;&#10;    vertx.createHttpServer().requestHandler(router::accept).listen(80);&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>当与开始<code>CWD</code>设置为<code>/</code> (<code>java -Dvertx.cwd=/ ...</code>)你就创建了一个简单的文件服务器，给所有服务器存储。 现在，假设你要启动这个程序，会打印如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Aug 26, 2015 2:02:18 PM io.vertx.core.http.impl.HttpServerImpl&#10;SEVERE: java.net.SocketException: Permission denied</span><br></pre></td></tr></table></figure>
<p>如果你现在使用<code>root</code>运行的，浏览器输入<code>http://localhost/etc/shadow</code>，恭喜你，你的服务器<code>logins</code> 和 <code>passwords</code> 暴露了 ！</p>
<p>有几种方法，可以root用户运行，使用<code>iptables</code>请求转发到更高的端口，使用<code>authbind</code>，配置代理服务器<code>ngnix</code>等…</p>
<h3 id="Sessions">Sessions</h3><p>许多应用程序要处理在某些时候用户会话。</p>
<p>会话<code>Cookie</code>应该有<code>SECURE</code>和<code>HTTPOnly</code>设置的标志，只发送<code>HTTPS</code>（在使用<code>HTTPS</code>？），也没有脚本访问<code>cookie</code>的客户端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router router = Router.router(vertx);&#10;&#10;    router.route().handler(CookieHandler.create());&#10;    router.route().handler(SessionHandler&#10;        .create(LocalSessionStore.create(vertx))&#10;        .setCookieHttpOnlyFlag(true)&#10;        .setCookieSecureFlag(true)&#10;    );&#10;&#10;    router.route().handler(routingContext -&#62; &#123;&#10;&#10;      Session session = routingContext.session();&#10;&#10;      Integer cnt = session.get(&#34;hitcount&#34;);&#10;      cnt = (cnt == null ? 0 : cnt) + 1;&#10;&#10;      session.put(&#34;hitcount&#34;, cnt);&#10;&#10;      routingContext.response().end(&#34;Hitcount: &#34; + cnt);&#10;    &#125;);&#10;&#10;    vertx.createHttpServer().requestHandler(router::accept).listen(8080);</span><br></pre></td></tr></table></figure>
<p>在这种情况下，检查浏览器，应该看到：</p>
<p><img src="http://vertx.io/assets/blog/vertx3-secure-webapps/nocookie.png" alt="image"></p>
<p>你的浏览器的脚本有读取的能力，可以嗅探劫持或篡改您的会话。</p>
<h3 id="Security_Headers">Security Headers</h3><p>有很多的安全<code>headers</code>有助于提高安全性，只需几行代码。 没有必要在这里解释，因为网上有很好的文章说的做得可能会比我更好。</p>
<p>怎么实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class App extends AbstractVerticle &#123;&#10;&#10;  @Override&#10;  public void start() &#123;&#10;&#10;    Router router = Router.router(vertx);&#10;    router.route().handler(ctx -&#62; &#123;&#10;      ctx.response()&#10;          // do not allow proxies to cache the data&#10;          .putHeader(&#34;Cache-Control&#34;, &#34;no-store, no-cache&#34;)&#10;          // prevents Internet Explorer from MIME - sniffing a&#10;          // response away from the declared content-type&#10;          .putHeader(&#34;X-Content-Type-Options&#34;, &#34;nosniff&#34;)&#10;          // Strict HTTPS (for about ~6Months)&#10;          .putHeader(&#34;Strict-Transport-Security&#34;, &#34;max-age=&#34; + 15768000)&#10;          // IE8+ do not allow opening of attachments in the context of this resource&#10;          .putHeader(&#34;X-Download-Options&#34;, &#34;noopen&#34;)&#10;          // enable XSS for IE&#10;          .putHeader(&#34;X-XSS-Protection&#34;, &#34;1; mode=block&#34;)&#10;          // deny frames&#10;          .putHeader(&#34;X-FRAME-OPTIONS&#34;, &#34;DENY&#34;);&#10;    &#125;);&#10;&#10;    vertx.createHttpServer().requestHandler(router::accept).listen(8080);&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="保护跨站请求伪造（CSRF）">保护跨站请求伪造（CSRF）</h3><p><code>Vert.x web</code>在<code>handler</code>里提供了<code>CSRF</code>保护。下面代码增加CSRF保护：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class App extends AbstractVerticle &#123;&#10;&#10;  @Override&#10;  public void start() &#123;&#10;&#10;    Router router = Router.router(vertx);&#10;&#10;    router.route().handler(CookieHandler.create());&#10;    router.route().handler(SessionHandler&#10;        .create(LocalSessionStore.create(vertx))&#10;        .setCookieHttpOnlyFlag(true)&#10;        .setCookieSecureFlag(true)&#10;    );&#10;    router.route().handler(CSRFHandler.create(&#34;not a good secret&#34;));&#10;&#10;    router.route().handler(ctx -&#62; &#123;&#10;      ...&#10;    &#125;);</span><br></pre></td></tr></table></figure>
<p>该处理器(handler)增加了一个CSRF令牌(token)。 为了改变<code>cookie</code>（XSRF-TOKEN），设置了一个独一无二的<code>token</code>，即预计返回一个（X-XSRF-TOKEN）header。</p>
<h3 id="限制上传">限制上传</h3><p>上传处理一定要定义一个上限，否则你会很容易受到DDoS攻击。 例如，看看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class App extends AbstractVerticle &#123;&#10;&#10;  @Override&#10;  public void start() &#123;&#10;&#10;    Router router = Router.router(vertx);&#10;&#10;    router.route().handler(BodyHandler.create());&#10;&#10;    router.route().handler(ctx -&#62; &#123;&#10;      ...</span><br></pre></td></tr></table></figure>
<p>现在，“好心人”可以随机生成一个1GB的垃圾文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if=/dev/urandom of=ddos bs=1G count=1</span><br></pre></td></tr></table></figure>
<p>然后把它上传到你的服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl --data-binary &#34;@ddos&#34; -H &#34;Content-Type: application/octet-stream&#34; -X POST http://localhost:8080/</span><br></pre></td></tr></table></figure>
<p>您的应用程序将愉快地处理，上面两步不断重复，它会耗尽磁盘空间或内存。 为了减轻这些类型的攻击，始终指定的最大允许上传的大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class App extends AbstractVerticle &#123;&#10;&#10;  private static final int KB = 1024;&#10;  private static final int MB = 1024 * KB;&#10;&#10;  @Override&#10;  public void start() &#123;&#10;&#10;    Router router = Router.router(vertx);&#10;    router.route().handler(BodyHandler.create().setBodyLimit(50 * MB));</span><br></pre></td></tr></table></figure>
<h3 id="最后">最后</h3><p>虽然只有几点，也应该记住。</p>
<p>当程序要用于生产，你还要注意更多：</p>
<ul>
<li><a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project" target="_blank" rel="external">OWASP Top Ten Project</a></li>
<li><a href="https://www.owasp.org/index.php/Preventing_SQL_Injection_in_Java" target="_blank" rel="external">Preventing SQL Injection in Java</a></li>
<li><a href="https://www.owasp.org/index.php/Testing_for_NoSQL_injection" target="_blank" rel="external">Testing for NoSQL injection</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交流群：&lt;code&gt;231419585&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此文只
    
    </summary>
    
      <category term="Vert.x3 系列" scheme="http://quanke.name/categories/Vert-x3-%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vert.x3" scheme="http://quanke.name/tags/Vert-x3/"/>
    
      <category term="Vertx" scheme="http://quanke.name/tags/Vertx/"/>
    
  </entry>
  
  <entry>
    <title>LiveOak 系列不再更新</title>
    <link href="http://quanke.name/2016/01/16/LiveOak-%E7%B3%BB%E5%88%97%E4%B8%8D%E5%86%8D%E6%9B%B4%E6%96%B0/"/>
    <id>http://quanke.name/2016/01/16/LiveOak-系列不再更新/</id>
    <published>2016-01-16T01:26:09.000Z</published>
    <updated>2016-01-16T01:27:23.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>交流群：<code>231419585</code></li>
<li>转载请注明出处，谢谢</li>
</ul>
<p>因为官方放弃此项目，LiveOak系列也不再更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交流群：&lt;code&gt;231419585&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为官
    
    </summary>
    
      <category term="MBaaS-LiveOak系列" scheme="http://quanke.name/categories/MBaaS-LiveOak%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="MBaaS" scheme="http://quanke.name/tags/MBaaS/"/>
    
  </entry>
  
  <entry>
    <title>Vert.x 实现REST</title>
    <link href="http://quanke.name/2016/01/15/Vert-x-%E5%AE%9E%E7%8E%B0REST/"/>
    <id>http://quanke.name/2016/01/15/Vert-x-实现REST/</id>
    <published>2016-01-15T13:19:45.000Z</published>
    <updated>2016-01-16T14:18:37.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>交流群：<code>231419585</code></li>
<li>转载请注明出处，谢谢</li>
</ul>
<h3 id="回顾">回顾</h3><p>在第一篇文章中开发了一个非常简单的Vert.x 3应用程序，还包括怎么测试、打包和执行。在第二篇文章中对端口进行了可变配置。</p>
<p>这篇文章中，开发一个CRUD（增删改查）应用，发布一个HTML页面，通过REST API与后台进行交互。RESTfull形式的API不简单，这篇文章中就不涉及了。</p>
<p>接下来，能看到：</p>
<ul>
<li>Vert.x Web - 使用Vert.x创建Web应用的框架</li>
<li>怎么发布静态资源</li>
<li>怎么开发REST API</li>
</ul>
<p>这篇文章开发的代码放在<a href="https://github.com/quanke/vertx3_study_demo/tree/master/my-vertx-first-app-rest" target="_blank" rel="external">GitHub</a>上，是从第二篇文章的代码基础上进行的。</p>
<h3 id="开始Vert-x_Web">开始Vert.x Web</h3><p>如果你看了<a href="http://quanke.name/2016/01/15/Vert-x-%E5%BA%94%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE/">前面的文章</a>，使用Vert.x Core来处理复杂的HTTP应用还是很麻烦的，所以就有了<a href="http://vertx.io/docs/vertx-web/java/" target="_blank" rel="external">Vert.x Web</a>，它可以使Vert.x开发一个web应用更加简单，而且不会改变Vert.x的思想。</p>
<p>更新pom.xml文件，添加下面的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;dependency&#62;&#10;  &#60;groupId&#62;io.vertx&#60;/groupId&#62;&#10;  &#60;artifactId&#62;vertx-web&#60;/artifactId&#62;&#10;  &#60;version&#62;3.0.0&#60;/version&#62;&#10;&#60;/dependency&#62;</span><br></pre></td></tr></table></figure>
<p>这就是使用Vert.x Web的唯一前提。</p>
<p>还记得在上一篇文章中，当请求<code>http://localhost:8080</code>时，返回一个<em>Hello World</em>消息，使用Vert.x Web完成同样的事情，打开<code>name.quanke.study.vertx.first.MyFirstVerticle.java</code> 类，修改<code>start</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;public void start(Future&#60;Void&#62; fut) &#123;&#10; // Create a router object.&#10; Router router = Router.router(vertx);&#10;&#10; // Bind &#34;/&#34; to our hello message - so we are still compatible.&#10; router.route(&#34;/&#34;).handler(routingContext -&#62; &#123;&#10;   HttpServerResponse response = routingContext.response();&#10;   response&#10;       .putHeader(&#34;content-type&#34;, &#34;text/html&#34;)&#10;       .end(&#34;&#60;h1&#62;Hello from my first Vert.x 3 application&#60;/h1&#62;&#34;);&#10; &#125;);&#10;&#10; // Create the HTTP server and pass the &#34;accept&#34; method to the request handler.&#10; vertx&#10;     .createHttpServer()&#10;     .requestHandler(router::accept)&#10;     .listen(&#10;         // Retrieve the port from the configuration,&#10;         // default to 8080.&#10;         config().getInteger(&#34;http.port&#34;, 8080),&#10;         result -&#62; &#123;&#10;           if (result.succeeded()) &#123;&#10;             fut.complete();&#10;           &#125; else &#123;&#10;             fut.fail(result.cause());&#10;           &#125;&#10;         &#125;&#10;     );&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在开始start方法里创建了一个<code>Router</code>对象。router是Vert.x Web的基础，负责分发HTTP请求到handler（处理器），在Vert.x Web中还有两个很重要的概念。</p>
<ul>
<li>Routes-定义请求的分发 </li>
<li>Handlers-这是实际处理请求并且返回结果的地方。Handlers可以被链接起来使用。</li>
</ul>
<p>如果明白了这3个概念（Router、Routes、Handlers），就明白了Vert.x Web的所有了。</p>
<p>仔细看看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.route(&#34;/&#34;).handler(routingContext -&#62; &#123;&#10;  HttpServerResponse response = routingContext.response();&#10;  response&#10;      .putHeader(&#34;content-type&#34;, &#34;text/html&#34;)&#10;      .end(&#34;&#60;h1&#62;Hello from my first Vert.x 3 application&#60;/h1&#62;&#34;);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>将访问”/“（<code>http://localhost:8080/</code>）的请求“路由”到指定的handler。Handlers接收RoutingContext对象。这个handler的方法和我们之前的代码很像，他们操作的是同一个HttpServerResponse类型的对象。</p>
<p>让我们来看看剩下的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertx&#10;    .createHttpServer()&#10;    .requestHandler(router::accept)&#10;    .listen(&#10;        // Retrieve the port from the configuration,&#10;        // default to 8080.&#10;        config().getInteger(&#34;http.port&#34;, 8080),&#10;        result -&#62; &#123;&#10;          if (result.succeeded()) &#123;&#10;            fut.complete();&#10;          &#125; else &#123;&#10;            fut.fail(result.cause());&#10;          &#125;&#10;        &#125;&#10;    );&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>除了改变了request handler，基本和之前的代码一样。传<code>router::accept</code>给handler。你可能对这个符号不太熟悉。它表示引用一个方法（这里是引用<code>router</code>的<code>accept</code>方法）。换句话说，当接收到一个请求的时候，告诉vert.x从<code>router</code>里调用<code>accept</code>方法。</p>
<p>让我们来看下它是怎么工作的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package&#10;java -jar target/my-first-app-1.0-SNAPSHOT-fat.jar</span><br></pre></td></tr></table></figure>
<p>浏览器打开<code>http://localhost:8080</code>，你会看到Hello的消息。</p>
<h3 id="发布静态资源">发布静态资源</h3><p>现在有了第一个使用Vert.x Web开发的应用。先在写增加一个index.html页面（静态资源）。</p>
<p>这个HTML页面将会是我们应用的入口。在src/main/resources/assets目录下，index.html文件在<a href="https://github.com/cescoffier/my-vertx-first-app/blob/post-3/src/main/resources/assets/index.html" target="_blank" rel="external">github</a>上。此文不涉及这个文件的细节。</p>
<p>基本上，就是一个简单的<code>CRUD</code>的UI界面，<code>actions</code>是由通过<code>AJAX</code>调用的<code>REST API</code>执行的。</p>
<p>创建完了页面后，编辑name.quanke.study.vertx.first.MyFirstVerticle类，并修改start方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;public void start(Future&#60;Void&#62; fut) &#123;&#10; Router router = Router.router(vertx);&#10; router.route(&#34;/&#34;).handler(routingContext -&#62; &#123;&#10;   HttpServerResponse response = routingContext.response();&#10;   response&#10;       .putHeader(&#34;content-type&#34;, &#34;text/html&#34;)&#10;       .end(&#34;&#60;h1&#62;Hello from my first Vert.x 3 application&#60;/h1&#62;&#34;);&#10; &#125;);&#10;&#10; // Serve static resources from the /assets directory&#10; // &#23558;&#35775;&#38382;&#8220;/assets/*&#8221;&#30340;&#35831;&#27714;route&#21040;&#8220;assets&#8221;&#30446;&#24405;&#19979;&#30340;&#36164;&#28304;&#10; &#10; router.route(&#34;/assets/*&#34;).handler(StaticHandler.create(&#34;assets&#34;));&#10;&#10; vertx&#10;     .createHttpServer()&#10;     .requestHandler(router::accept)&#10;     .listen(&#10;         // Retrieve the port from the configuration,&#10;         // default to 8080.&#10;         config().getInteger(&#34;http.port&#34;, 8080),&#10;         result -&#62; &#123;&#10;           if (result.succeeded()) &#123;&#10;             fut.complete();&#10;           &#125; else &#123;&#10;             fut.fail(result.cause());&#10;           &#125;&#10;         &#125;&#10;     );&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>就这段代码和前面的不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.route(&#34;/assets/*&#34;).handler(StaticHandler.create(&#34;assets&#34;));</span><br></pre></td></tr></table></figure>
<p>这一行是什么意思？挺简单的。将访问“/assets/*”的请求route到“assets”目录下的资源。现在可以通过<code>http://localhost:8080/assets/index.html</code>来访问index.html了。</p>
<p>测试之前，我们花一些时间来看一下handler的创建。所有的处理请求动作在Vert.x Web里都实现成handler。而创建一个handler需要调用<code>create</code>方法。</p>
<p>编译、运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package&#10;java -jar target/my-first-app-1.0-SNAPSHOT-fat.jar</span><br></pre></td></tr></table></figure>
<p>浏览器，输入<code>http://localhost:8080/assets/index.html</code>。</p>
<p>现在这个table是空的。那是因为我们还没有实现REST的API。现在让我们来开始吧。</p>
<h3 id="使用Vert-x_Web实现REST_API">使用Vert.x Web实现REST API</h3><p>Vert.x Web实现REST API很简单。看下面：</p>
<ul>
<li>GET /api/whiskies =&gt; 获取所有的威士忌（getAll）</li>
<li>GET /api/whiskies/:id =&gt; 获取指定id的威士忌（getOne）</li>
<li>POST /api/whiskies =&gt;添加一瓶威士忌（addOne）</li>
<li>PUT /api/whiskies/:id =&gt; 编辑一瓶威士忌(updateOne)</li>
<li>DELETE /api/whiskies/id =&gt; 删除一瓶威士忌(deleteOne)</li>
</ul>
<h5 id="我们需要一些数据。。。">我们需要一些数据。。。</h5><p>在实现REST API之前，需要创建Whisky的数据模型。使用下面的内容创建<code>src/main/java/quanke/name/study/vertx/first/Whisky.java</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package name.quanke.study.vertx.first;&#10;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;public class Whisky &#123;&#10;&#10;  private static final AtomicInteger COUNTER = new AtomicInteger();&#10;&#10;  private final int id;&#10;&#10;  private String name;&#10;&#10;  private String origin;&#10;&#10;  public Whisky(String name, String origin) &#123;&#10;    this.id = COUNTER.getAndIncrement();&#10;    this.name = name;&#10;    this.origin = origin;&#10;  &#125;&#10;&#10;  public Whisky() &#123;&#10;    this.id = COUNTER.getAndIncrement();&#10;  &#125;&#10;&#10;  public String getName() &#123;&#10;    return name;&#10;  &#125;&#10;&#10;  public String getOrigin() &#123;&#10;    return origin;&#10;  &#125;&#10;&#10;  public int getId() &#123;&#10;    return id;&#10;  &#125;&#10;&#10;  public void setName(String name) &#123;&#10;    this.name = name;&#10;  &#125;&#10;&#10;  public void setOrigin(String origin) &#123;&#10;    this.origin = origin;&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个很简单的bean类。因为Vert.x依赖Jackson来处理JSON格式,Jackson能够自动序列化和反序列化bean类，让代码变得更简单，所以选择这样的格式。</p>
<p>现在，创建几瓶威士忌。在MyFirstVerticle类中，添加下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Store our product&#10;// &#23384;&#20648;&#20135;&#21697;&#10;private Map&#60;Integer, Whisky&#62; products = new LinkedHashMap&#60;&#62;();&#10;// Create some product&#10;// &#21019;&#24314;&#19968;&#20123;&#20135;&#21697;&#10;private void createSomeData() &#123;&#10;  Whisky bowmore = new Whisky(&#34;Bowmore 15 Years Laimrig&#34;, &#34;Scotland, Islay&#34;);&#10;  products.put(bowmore.getId(), bowmore);&#10;  Whisky talisker = new Whisky(&#34;Talisker 57&#176; North&#34;, &#34;Scotland, Island&#34;);&#10;  products.put(talisker.getId(), talisker);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在<code>start</code>方法里，调用<code>createSomeData</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;public void start(Future&#60;Void&#62; fut) &#123;&#10;&#10;  createSomeData();&#10;&#10;  // Create a router object.&#10;  Router router = Router.router(vertx);&#10;&#10;  // Rest of the method&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在这里并没有一个后台数据库。仅使用一个map，将数据存储在内存中。添加后端数据库的介绍我准备放在另一篇文章中讲。</p>
<h3 id="获得产品（威士忌）">获得产品（威士忌）</h3><p><code>GET /api/whiskies</code>，JSON数组中返回产品列表。</p>
<p>在<code>start</code>方法里，添加下面这行（static handler）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.get(&#34;/api/whiskies&#34;).handler(this::getAll);</span><br></pre></td></tr></table></figure>
<p>告诉<code>router</code>调用<code>getAll</code>方法来处理<code>&quot;/api/whiskies&quot;</code>的GET请求。代码可以写在<code>handler</code>里，但是为了让代码更加清晰，另外创建一个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void getAll(RoutingContext routingContext) &#123;&#10;  routingContext.response()&#10;      .putHeader(&#34;content-type&#34;, &#34;application/json; charset=utf-8&#34;)&#10;      .end(Json.encodePrettily(products.values()));&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>每一个handler（比如：请看上面的代码）都会接受一个<code>RoutingContext</code>参数。通过设置<code>content-type</code>和一些内容来填充<code>response</code>。因为内容可能会碰到特殊的字符，所以强制使用UTF-8的格式。创建内容的时候，并不需要自己去处理JSON格式的字符串。Vert.x有处理Json的API。使用Json.encodePrettily(products.values())处理JSON字符串。本应使用Json.encodePrettily(products)，但是为了让JavaScript代码更简单，我们仅返回威士忌（产品）的数据集合，并没有返回包含<code>Id=&gt;Bottle</code>的键值对。</p>
<p>打包运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package&#10;java -jar target/my-first-app-1.0-SNAPSHOT-fat.jar</span><br></pre></td></tr></table></figure>
<p>浏览器访问<code>http://localhost:8080/assets/index.html</code>，然后你将会看到下面这个页面。</p>
<p><img src="http://vertx.io/assets/blog/intro-series/post-3-My_Whisky_Collection.png" alt="image"></p>
<p>很好奇，想看一下REST API到底返回了什么。打开浏览器，访问<a href="http://localhost:8080/api/whiskies。你会看到下面这样的信息：" target="_blank" rel="external">http://localhost:8080/api/whiskies。你会看到下面这样的信息：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ &#123;&#10;  &#34;id&#34; : 0,&#10;  &#34;name&#34; : &#34;Bowmore 15 Years Laimrig&#34;,&#10;  &#34;origin&#34; : &#34;Scotland, Islay&#34;&#10;&#125;, &#123;&#10;  &#34;id&#34; : 1,&#10;  &#34;name&#34; : &#34;Talisker 57&#176; North&#34;,&#10;  &#34;origin&#34; : &#34;Scotland, Island&#34;&#10;&#125; ]</span><br></pre></td></tr></table></figure>
<h3 id="创建一个产品">创建一个产品</h3><p>能获取到威士忌（产品）了，现在需要创建一个产品。不像之前的REST API，这一次，需要读取<code>request</code>的<code>body</code>。因为性能的原因，它应该被显式地启用。不要怕，这也仅仅是一个<code>handler</code>而已。</p>
<p>在<code>start</code>方法中，添加下面的内容到<code>getAll</code>的后面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.route(&#34;/api/whiskies*&#34;).handler(BodyHandler.create());&#10;router.post(&#34;/api/whiskies&#34;).handler(this::addOne);</span><br></pre></td></tr></table></figure>
<p>第一行允许<code>&quot;/api/whiskies&quot;</code>下的所有<code>route</code>读取请求的<code>body</code>。通过使用<code>router.route().handler(BodyHandler.create())</code>，能让它在全局生效。</p>
<p>第二行将对<code>/api/whiskies</code>的POST请求映射到<code>addOne</code>方法。让我们来创建这个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void addOne(RoutingContext routingContext) &#123;&#10;  final Whisky whisky = Json.decodeValue(routingContext.getBodyAsString(),&#10;      Whisky.class);&#10;  products.put(whisky.getId(), whisky);&#10;  routingContext.response()&#10;      .setStatusCode(201)&#10;      .putHeader(&#34;content-type&#34;, &#34;application/json; charset=utf-8&#34;)&#10;      .end(Json.encodePrettily(whisky));&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>开始从请求的<code>body</code>中取出<code>Whisky</code>对象。只是将body读成一个字符串并将它传入到Json.decodeValue方法里。Whisky这个对象一旦创建好，将被添加到后台的map中，并以JSON的格式返回。</p>
<p>重新编译并且运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package&#10;java -jar target/my-first-app-1.0-SNAPSHOT-fat.jar</span><br></pre></td></tr></table></figure>
<p>刷新HTML页面，点击<code>Add a new bottle</code>按钮。输入数据，如：<code>“quanke”</code> 作为名字， “quanke.name” 作为产地 ，就OK了。</p>
<p><em>状态码 201 ？<br><code>CREATED</code>和在REST API中创建一个entity时，response的状态码为201。。默认的vert.x web设置一个200的状态码代表OK。</em></p>
<h3 id="删除一个产品">删除一个产品</h3><p>在<code>start</code>方法里，添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.delete(&#34;/api/whiskies/:id&#34;).handler(this::deleteOne);</span><br></pre></td></tr></table></figure>
<p>在<code>URL</code>里，参数为：<code>:id</code>。在处理一个相匹配的请求的时候，Vert.x提取路径中与这个参数对应的一段，能够在handler中获得。例如，<code>/api/whiskies/0</code>将<code>id</code>映射为<code>0</code>。</p>
<p>看一下在<code>handler</code>方法中这个参数是怎样被使用的。创建一个<code>deleteOne</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void deleteOne(RoutingContext routingContext) &#123;&#10;  String id = routingContext.request().getParam(&#34;id&#34;);&#10;  if (id == null) &#123;&#10;    routingContext.response().setStatusCode(400).end();&#10;  &#125; else &#123;&#10;    Integer idAsInteger = Integer.valueOf(id);&#10;    products.remove(idAsInteger);&#10;  &#125;&#10;  routingContext.response().setStatusCode(204).end();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><em>状态码 204 ？<br>状态码为204 - NO CONTENT。HTTP delete动作通常都是无返回内容的。</em></p>
<h3 id="其他方法">其他方法</h3><p>实现getOne和updateOne很简单，和上面的差不多，此文不再详细介绍。源码在<a href="https://github.com/quanke/vertx3_study_demo/tree/master/my-vertx-first-app-rest" target="_blank" rel="external">github</a>上</p>
<h3 id="总结">总结</h3><p>此文介绍了如何用Vert.x web轻松的实现一个REST API，如何访问静态资源。比以前的文章复杂些，但仍然还是很简单。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交流群：&lt;code&gt;231419585&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id
    
    </summary>
    
      <category term="Vert.x3 系列" scheme="http://quanke.name/categories/Vert-x3-%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vert.x3" scheme="http://quanke.name/tags/Vert-x3/"/>
    
      <category term="Vertx" scheme="http://quanke.name/tags/Vertx/"/>
    
  </entry>
  
  <entry>
    <title>Vert.x 应用的配置</title>
    <link href="http://quanke.name/2016/01/15/Vert-x-%E5%BA%94%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://quanke.name/2016/01/15/Vert-x-应用的配置/</id>
    <published>2016-01-14T23:40:12.000Z</published>
    <updated>2016-01-15T05:02:59.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>交流群：<code>231419585</code></li>
<li>转载请注明出处，谢谢</li>
</ul>
<p>在上篇文章中，开发了一个简单的Vert.x应用，介绍了怎么测试，打包和执行，这仅仅是一个开始，在这篇文章中，我们通过配置来提高应用。</p>
<p>还记得，在上一个应用中有HTTP server，监听<code>8080</code>端口，应答一个“Hello”的消息，上篇文章的代码在<a href="https://github.com/quanke/vertx3_study_demo/tree/master/my-vertx-first-app" target="_blank" rel="external">这里</a>，本篇文章的代码在<a href="https://github.com/quanke/vertx3_study_demo/tree/master/my-vertx-first-app-config" target="_blank" rel="external">github</a></p>
<h3 id="为什么需要配置？">为什么需要配置？</h3><p>这个问题非常好。这个应用是正常工作的，但是如果当你部署在8080端口已经被占领了的机器上，如果要部署在这个机器上，我们就需要到代码里修改应用程序和测试里的端口了，这不能忍受，很幸运的是Vert.x配置一下就可以了。</p>
<p>Vert.x使用的是JSON格式配置的，所以很简单，可以使用API传给verticle或者命令行，我们来看一看。</p>
<h3 id="不使用_‘8080’_端口">不使用 ‘8080’ 端口</h3><p>第一步是修改<code>name/quanke/study/vertx/first/MyFirstVerticle.java</code>类，从配置里读取端口，而不<code>8080</code>绑定，默认是<code>8080</code>端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void start(Future&#60;Void&#62; fut) &#123;&#10;  vertx&#10;      .createHttpServer()&#10;      .requestHandler(r -&#62; &#123;&#10;        r.response().end(&#34;Hello from my first &#34; +&#10;            &#34;Vert.x 3 application&#34;);&#10;      &#125;)&#10;      .listen(&#10;          // Retrieve the port from the configuration,&#10;          //&#20174;&#37197;&#32622;&#37324;&#26816;&#32034;&#31471;&#21475;&#10;          // default to 8080.&#10;          //&#40664;&#35748;8080&#10;          config().getInteger(&#34;http.port&#34;, 8080),&#10;          result -&#62; &#123;&#10;            if (result.succeeded()) &#123;&#10;              fut.complete();&#10;            &#125; else &#123;&#10;              fut.fail(result.cause());&#10;            &#125;&#10;          &#125;&#10;      );&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>与上一版本的区别仅仅是<code>listen</code>里面的第一个参数<code>8080</code>换成<code>config().getInteger(&quot;http.port&quot;, 8080)</code>。这里，我们的代码会请求这个配置并检查<code>http.port</code>属性是否配置了。如果没有，将会默认使用<code>8080</code>端口。配置信息是从<code>JsonObject</code>中返回的。</p>
<p>默认还是使用<code>8080</code>，所以打包运行和以前一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package&#10;java -jar target/my-first-app-1.0-SNAPSHOT-fat.jar</span><br></pre></td></tr></table></figure>
<h3 id="使用API的方式配置_-_在测试中随机生成端口号">使用API的方式配置 - 在测试中随机生成端口号</h3><p>在测试代码中，我们把端口修改成<code>8081</code>，部署（deploying）<code>verticle</code>的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertx.deployVerticle(MyFirstVerticle.class.getName(), context.asyncAssertSuccess());</span><br></pre></td></tr></table></figure>
<p>传入部署（deploying）选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port = 8081;&#10;DeploymentOptions options = new DeploymentOptions()&#10;    .setConfig(new JsonObject().put(&#34;http.port&#34;, port)&#10;);&#10;vertx.deployVerticle(MyFirstVerticle.class.getName(), options, context.asyncAssertSuccess());</span><br></pre></td></tr></table></figure>
<p><em>post在全局变量里面声明的<code>private Integer port;</code></em></p>
<p><code>DeploymentOptions</code>对象可以定义多个参数。将JsonObject注入到verticle的config()方法中。</p>
<p>连接服务器的代码需要修改一下，端口要和测试里面的一样才行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertx.createHttpClient().getNow(port, &#34;localhost&#34;, &#34;/&#34;, response -&#62; &#123;&#10;  response.handler(body -&#62; &#123;&#10;    context.assertTrue(body.toString().contains(&#34;Hello&#34;));&#10;    async.complete();&#10;  &#125;);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>这个并没有完全解决问题，如果8081端口也被占用了怎么办？我们使用随机端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServerSocket socket = new ServerSocket(0);&#10;port = socket.getLocalPort();&#10;socket.close();&#10;&#10;DeploymentOptions options = new DeploymentOptions()&#10;    .setConfig(new JsonObject().put(&#34;http.port&#34;, port)&#10;    );&#10;&#10;vertx.deployVerticle(MyFirstVerticle.class.getName(), options, context.asyncAssertSuccess());</span><br></pre></td></tr></table></figure>
<p>这种方式是很简单。打开<code>server socket</code>获取一个随机的端口（这也是为什么将0作为参数）。检索如果端口被占用就关闭socket。需要注意的是，这个方法并不完美，如果端口在socket.close()方法之后和HTTP服务器启动之前被占用的话，会失败。然而，这种情况如果被朋友的话，说明你非常幸运，所以大多数情况下都是没有问题的。</p>
<p>测试一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean test</span><br></pre></td></tr></table></figure>
<h3 id="外部配置-在另一个端口运行">外部配置-在另一个端口运行</h3><p>在生产环境中，随机端口并不是我们想要的。所以，在实际执行应用的时候，我们需要将配置写在一个外部的文件里。这个配置的文件使用json格式。</p>
<p>创建<code>src/main/conf/my-application-conf.json</code>，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#10;  &#34;http.port&#34; : 8082&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>通过执行下面这句命令，在启动应用的时候，加载配置文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar target/my-first-app-1.0-SNAPSHOT-fat.jar -conf src/main/conf/my-application-conf.json</span><br></pre></td></tr></table></figure>
<p>打开浏览器，然后访问 <code>http://localhost:8082</code> 。</p>
<p><em>编辑JSON文件，重新打包运行，端口就修改了，不需要修改源码。</em></p>
<p>这是怎么工作的？<code>fat jar</code>是使用<code>Starter</code>类来加载应用程序。当部署<code>verticle</code>的时候，这个类会读取<code>-conf</code>参数，相应的会创建一个<code>DeploymentOptions</code>对象。</p>
<h3 id="总结">总结</h3><p>在第一个应用的基础上，只增加了非常简单的代码就完成了Vertx的配置工作。下篇文章我们一起来看看通过<code>vertx-web</code>开发一个提供静态页面和<code>REST API</code>的小应用，这个更加厉害，但是也是非常简单。</p>
<p><em>Happy coding &amp; Stay tuned !</em></p>
<p>本人英语比较烂，建议看<a href="http://vertx.io/blog/vert-x-application-configuration/" target="_blank" rel="external">原文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交流群：&lt;code&gt;231419585&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上篇
    
    </summary>
    
      <category term="Vert.x3 系列" scheme="http://quanke.name/categories/Vert-x3-%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vert.x3" scheme="http://quanke.name/tags/Vert-x3/"/>
    
      <category term="Vertx" scheme="http://quanke.name/tags/Vertx/"/>
    
  </entry>
  
  <entry>
    <title>我的第一个Vert.x 3 应用</title>
    <link href="http://quanke.name/2016/01/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAVert-x-3-%E5%BA%94%E7%94%A8/"/>
    <id>http://quanke.name/2016/01/12/我的第一个Vert-x-3-应用/</id>
    <published>2016-01-12T11:44:56.000Z</published>
    <updated>2016-01-15T05:21:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li>
<li>交流群：<code>231419585</code></li>
<li>转载请注明出处，谢谢</li>
</ul>
<p>如果，你听到有人说Vert.x 是牛逼的。非常好！但是你自己想要尝试的话，Ok great，那么下一个问题自然是“从哪里开始？”，这篇文章是一个很好的起点。文章展示了怎么构建一个非常简单的 vert.x 应用（这没什么大不了的），怎样测试和执行vert.x应用。</p>
<p>文章里提到的代码在<a href="https://github.com/quanke/vertx3_study_demo/tree/master/my-vertx-first-app" target="_blank" rel="external">github</a> 。</p>
<h3 id="开始">开始</h3><p>首先，创建一个项目，在这篇文章中使用<code>Apache Maven</code>,当然你可以使用<code>Gradle</code> 或者其他工具，使用<code>Maven jar archetype</code> 创建结构，但基本上只需要一个目录。</p>
<ul>
<li><code>src/main/java</code> 目录</li>
<li><code>src/test/java</code> 目录</li>
<li><code>pom.xml</code> 文件</li>
</ul>
<p>会得到一个像这样的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#10;&#9500;&#9472;&#9472; pom.xml&#10;&#9500;&#9472;&#9472; src&#10;&#9474;   &#9500;&#9472;&#9472; main&#10;&#9474;   &#9474;   &#9492;&#9472;&#9472; java&#10;&#9474;   &#9492;&#9472;&#9472; test&#10;&#9474;       &#9492;&#9472;&#9472; java</span><br></pre></td></tr></table></figure>
<p><code>pom.xml</code> 文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;project xmlns=&#34;http://maven.apache.org/POM/4.0.0&#34;&#10;         xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;&#10;         xsi:schemaLocation=&#34;http://maven.apache.org/POM/4.0.0&#10;                      http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;&#62;&#10;  &#60;modelVersion&#62;4.0.0&#60;/modelVersion&#62;&#10;  &#60;groupId&#62;name.quanke.study.vertx.first&#60;/groupId&#62;&#10;  &#60;artifactId&#62;my-first-app&#60;/artifactId&#62;&#10;  &#60;version&#62;1.0-SNAPSHOT&#60;/version&#62;&#10;&#10;  &#60;dependencies&#62;&#10;    &#60;dependency&#62;&#10;      &#60;groupId&#62;io.vertx&#60;/groupId&#62;&#10;      &#60;artifactId&#62;vertx-core&#60;/artifactId&#62;&#10;      &#60;version&#62;3.0.0&#60;/version&#62;&#10;    &#60;/dependency&#62;&#10;  &#60;/dependencies&#62;&#10;&#10;  &#60;build&#62;&#10;    &#60;plugins&#62;&#10;      &#60;plugin&#62;&#10;        &#60;artifactId&#62;maven-compiler-plugin&#60;/artifactId&#62;&#10;        &#60;version&#62;3.3&#60;/version&#62;&#10;        &#60;configuration&#62;&#10;          &#60;source&#62;1.8&#60;/source&#62;&#10;          &#60;target&#62;1.8&#60;/target&#62;&#10;        &#60;/configuration&#62;&#10;      &#60;/plugin&#62;&#10;    &#60;/plugins&#62;&#10;  &#60;/build&#62;&#10;&#10;&#60;/project&#62;</span><br></pre></td></tr></table></figure>
<p>这个 pom.xml 文件非常简单：</p>
<ul>
<li>声明了一个 vertx-core 依赖</li>
<li>配置了maven-compiler-plugin 插件（使用的是<code>Java 8</code>）.</li>
</ul>
<blockquote>
<p>第二点非常重要，<code>Vert.x</code> 只支持<code>Java 8</code>。</p>
</blockquote>
<h3 id="编码！">编码！</h3><p>OK，我们已经创建了一个<code>pom.xml</code> 文件，接下来正式开始编码，创建 <code>src/main/java/name/quanke/study/vertx/first/MyFirstVerticle.java</code>文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package name.quanke.study.vertx.first;&#10;&#10;import io.vertx.core.AbstractVerticle;&#10;import io.vertx.core.Future;&#10;&#10;public class MyFirstVerticle extends AbstractVerticle &#123;&#10;&#10;  @Override&#10;  public void start(Future&#60;Void&#62; fut) &#123;&#10;    vertx&#10;        .createHttpServer()&#10;        .requestHandler(r -&#62; &#123;&#10;          r.response().end(&#34;&#60;h1&#62;Hello from my first &#34; +&#10;              &#34;Vert.x 3 application&#60;/h1&#62;&#34;);&#10;        &#125;)&#10;        .listen(8080, result -&#62; &#123;&#10;          if (result.succeeded()) &#123;&#10;            fut.complete();&#10;          &#125; else &#123;&#10;            fut.fail(result.cause());&#10;          &#125;&#10;        &#125;);&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这个实际上不是最优秀的应用，这个类继承<code>AbstractVerticle</code>，在<code>Vert.x</code>的世界里<code>verticle</code>就是组件（是Vert.x的之行单元），通过继承<code>AbstractVerticle</code>类，获得<code>vertx</code>的入口。</p>
<p>当<code>verticle</code>部署后会调用<code>start</code>方法，我们也能实现 <code>stop</code> 方法，在这个方法里回收资源，<code>start</code>方法接收<code>Future</code>对象的参数，可以告诉用户是执行完成还是报出错误，<code>Vert.x</code>是异步执行的，运行的时候不会等到<code>start</code>方法执行完成，所以 <code>Future</code> 参数是非常重要的，可以通知是否已经执行完成。</p>
<p>在<code>start</code>方法里创建了一个HTTP 服务和一个请求处理器（handler），这个请求处理器使用lambda表达式，通过<code>requestHandler</code>方法，每次服务器收到请求，都会返回“Hello。。。”（也没有什么其他可以告诉你的东西了。。。），最后服务器绑定了一个8080端口，这里可能会失败（因为8080端口可能被使用了），通过lambda表达式检查是否连接成功，就想上面说的，调用fut.complete表示成功，调用 fut.fail 报告失败。</p>
<p>使用下面的命令尝试着编译应用（首先你要安装好了maven，此命令在pom.xml目录下执行，知道使用maven的都懂得）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean compile</span><br></pre></td></tr></table></figure>
<p>如果幸运，编译应该是成功的。</p>
<p>应用就编写到这里，是不是很简单？</p>
<h3 id="测试">测试</h3><p>应用开发完成了，但是我们从来都不是很认真的，所有我们需要测试一下，测试使用<code>JUnit</code> 和 <code>vertx-unit</code>。</p>
<p>打开<code>pom.xml</code>文件，增加两个依赖（dependencies）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;dependency&#62;&#10;  &#60;groupId&#62;junit&#60;/groupId&#62;&#10;  &#60;artifactId&#62;junit&#60;/artifactId&#62;&#10;  &#60;version&#62;4.12&#60;/version&#62;&#10;  &#60;scope&#62;test&#60;/scope&#62;&#10;&#60;/dependency&#62;&#10;&#60;dependency&#62;&#10;  &#60;groupId&#62;io.vertx&#60;/groupId&#62;&#10;  &#60;artifactId&#62;vertx-unit&#60;/artifactId&#62;&#10;  &#60;version&#62;3.0.0&#60;/version&#62;&#10;  &#60;scope&#62;test&#60;/scope&#62;&#10;&#60;/dependency&#62;</span><br></pre></td></tr></table></figure>
<p>创建 <code>src/main/java/name/quanke/study/vertx/first/MyFirstVerticleTest.java</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package name.quanke.study.vertx.first;&#10;import io.vertx.core.Vertx;&#10;import io.vertx.ext.unit.Async;&#10;import io.vertx.ext.unit.TestContext;&#10;import io.vertx.ext.unit.junit.VertxUnitRunner;&#10;import org.junit.After;&#10;import org.junit.Before;&#10;import org.junit.Test;&#10;import org.junit.runner.RunWith;&#10;&#10;@RunWith(VertxUnitRunner.class)&#10;public class MyFirstVerticleTest &#123;&#10;&#10;  private Vertx vertx;&#10;&#10;  @Before&#10;  public void setUp(TestContext context) &#123;&#10;    vertx = Vertx.vertx();&#10;    vertx.deployVerticle(MyFirstVerticle.class.getName(),&#10;        context.asyncAssertSuccess());&#10;  &#125;&#10;&#10;  @After&#10;  public void tearDown(TestContext context) &#123;&#10;    vertx.close(context.asyncAssertSuccess());&#10;  &#125;&#10;&#10;  @Test&#10;  public void testMyApplication(TestContext context) &#123;&#10;    final Async async = context.async();&#10;&#10;    vertx.createHttpClient().getNow(8080, &#34;localhost&#34;, &#34;/&#34;,&#10;     response -&#62; &#123;&#10;      response.handler(body -&#62; &#123;&#10;        context.assertTrue(body.toString().contains(&#34;Hello&#34;));&#10;        async.complete();&#10;      &#125;);&#10;    &#125;);&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在这里使用<code>JUnit</code>测试<code>verticle</code>，也会使用到 <code>vertx-unit</code> 自定义的<code>runner</code>，<code>vert.x-unit</code>很容易测试异步的<code>vert.x</code>应用。</p>
<p>在<code>setUp</code>方法里，创建了一个<code>Vertx</code>实例，<code>deploy</code>了<code>verticle</code> ,你可能已经注意到了，这与传统<code>JUnit</code>的<code>@Before</code>不一样，它接收了一个<code>TestContext</code>参数，<code>TestContext</code>对象让我们可以控制异步的测试，例如：当我们<code>deploy</code>了异步<code>verticle</code>，多个<code>Vertx</code>实例相互作用时，不能检测它的正确性，<code>deployVerticle</code>方法的第二个参数返回一个handler：<code>context.asyncAssertSuccess()</code>，如果<code>verticle</code>的状态是失败，那这个测试就是失败的，此外会等待<code>verticle</code>完成启动，还记得，在<code>verticle</code>里，我们调用了<code>fut.complete()</code>方法，直到等到调用<code>fut.complete()</code>方法才返回状态。</p>
<p><code>tearDown</code>方法比较简单，负责回收我们创建的<code>vertx</code>对象。</p>
<p>现在我们看一下测试应用的<code>testMyApplication</code>方法，给应用发出请求并且拦截一个返回，发出请求和接收答复都是异步的，我们需要一种方法来控制，<code>setUp</code>和<code>tearDown</code>方法接收一个<code>TestContext</code>对象，当这个测试完成的时候，通过我们这个对象创建的异步的处理器（<code>async</code>），通知测试框架（使用<code>async.complete()</code>）</p>
<p>像这样，一个异步处理器创建好了，我们使用<code>getNow()</code>方法（<code>getNow()</code>方法是<code>get(...).end()</code>的捷径），创建一个HTTP客户端和发一个HTTP请求给我们的应用，响应使用<code>lambda</code>处理，通过另一个<code>lambda</code>的<code>handler</code>方法接收一个<code>response body</code>，这个<code>body</code>参数是这个<code>response body</code>（如<code>buffer</code>对象），检测<code>body</code>是否等于<code>“Hello”</code>字符串，并且宣布测试完成（<code>async.complete()</code>）。</p>
<p>让我们花一个分钟的时间提一下这个断言，不像传统的使用<code>context.assert...</code>断言，如果断言失败，它会立即中断测试，因为<code>Vert.x</code> 程序各方面都是异步的,所以使用这种方式断言测试很重要。</p>
<p>可以使用IDE或者Maven运行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean test</span><br></pre></td></tr></table></figure>
<h3 id="打包">打包</h3><p>总结一下，我们有了应用程序和测试，接下来，给应用打包，在这篇文章中我们把应用打 成<code>fat jar</code>包，一个 <code>fat jar</code>包是一个可以独立执行的<code>jar</code>文件，它包含所有的运行程序所需要的依赖，<code>Vert.x</code>使用这种打包的方式非常方便，仅仅只有一个文件，这使它非常容易执行。</p>
<p>创建一个 <code>fat jar</code> 便捷<code>pom.xml</code>文件，把下面的的代码增加到<code>&lt;/plugins&gt;</code>标签之前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;plugin&#62;&#10;        &#60;groupId&#62;org.apache.maven.plugins&#60;/groupId&#62;&#10;        &#60;artifactId&#62;maven-shade-plugin&#60;/artifactId&#62;&#10;        &#60;version&#62;2.3&#60;/version&#62;&#10;        &#60;executions&#62;&#10;          &#60;execution&#62;&#10;            &#60;phase&#62;package&#60;/phase&#62;&#10;            &#60;goals&#62;&#10;              &#60;goal&#62;shade&#60;/goal&#62;&#10;            &#60;/goals&#62;&#10;            &#60;configuration&#62;&#10;              &#60;transformers&#62;&#10;                &#60;transformer&#10;                  implementation=&#34;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&#34;&#62;&#10;                  &#60;manifestEntries&#62;&#10;                    &#60;Main-Class&#62;io.vertx.core.Starter&#60;/Main-Class&#62;&#10;                    &#60;Main-Verticle&#62;name.quanke.study.vertx.first.MyFirstVerticle&#60;/Main-Verticle&#62;&#10;                  &#60;/manifestEntries&#62;&#10;                &#60;/transformer&#62;&#10;              &#60;/transformers&#62;&#10;              &#60;artifactSet/&#62;&#10;              &#60;outputFile&#62;$&#123;project.build.directory&#125;/$&#123;project.artifactId&#125;-$&#123;project.version&#125;-fat.jar&#60;/outputFile&#62;&#10;            &#60;/configuration&#62;&#10;          &#60;/execution&#62;&#10;        &#60;/executions&#62;&#10;      &#60;/plugin&#62;</span><br></pre></td></tr></table></figure>
<p>使用<a href="https://maven.apache.org/plugins/maven-shade-plugin/" target="_blank" rel="external">maven-shade-plugin</a> 创建<code>fat jar</code>。在<code>manifestEntries</code>标签里声明我们的<code>verticle</code>，你也许不知道从哪里来的<code>Starter</code>类，实际上，它是在<code>vertx</code>实例化和部署<code>verticle</code>的时候就有创建。</p>
<p>这个插件的配置就是这样，我们执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
<p>应该会创建一个<code>target/my-first-app-1.0-SNAPSHOT-fat.jar</code>，里面嵌入了应用所有的依赖（包含<code>vert.x</code>自己）。</p>
<h3 id="执行">执行</h3><p>嗯，很高兴拥有一个 <code>fal jar</code>,但我们希望看到我们的应用程序的运行！正如上面所说，多亏了<code>fat jar</code>包装，运行vert.x应用程序是容易的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar target/my-first-app-1.0-SNAPSHOT-fat.jar</span><br></pre></td></tr></table></figure>
<p>然后，打开浏览器访问 <a href="http://localhost:8080。" target="_blank" rel="external">http://localhost:8080。</a></p>
<p><code>CTRL+C</code>停止应用运行。</p>
<h3 id="总结">总结</h3><p>这个Vert.x 3速成班告诉你，怎么使用Vert.x 3开发一个简单的应用，怎么测试、打包和运行，现在知道了在Vert.x 3 上任意创建令人惊奇的系统。接下来的时间看看<a href="http://quanke.name/2016/01/15/Vert-x-应用的配置/">怎么配置我们的应用</a>。</p>
<p><em>Happy coding &amp; Stay tuned !</em></p>
<p>本人英语比较烂，建议看<a href="http://vertx.io/blog/my-first-vert-x-3-application/index.html" target="_blank" rel="external">原文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交流群：&lt;code&gt;231419585&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果，
    
    </summary>
    
      <category term="Vert.x3 系列" scheme="http://quanke.name/categories/Vert-x3-%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vert.x3" scheme="http://quanke.name/tags/Vert-x3/"/>
    
      <category term="Vertx" scheme="http://quanke.name/tags/Vertx/"/>
    
  </entry>
  
</feed>
